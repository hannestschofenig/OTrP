<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4648 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY RFC7159 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7159.xml">
<!ENTITY RFC7515 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7515.xml">
<!ENTITY RFC7516 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7516.xml">
<!ENTITY RFC7517 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7517.xml">
<!ENTITY RFC7518 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7518.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<!-- <?rfc compact="yes" ?> -->
<?rfc subcompact="no" ?>
<rfc category="std" docName="draft-ietf-teep-opentrustprotocol-04.txt" ipr="trust200902"
  submissionType="IETF">
  <front>
    <title abbrev="OTrP">The Open Trust Protocol (OTrP)</title>

    <author fullname="Mingliang Pei" initials="M." surname="Pei">
      <organization>Symantec</organization>
      <address>
        <postal>
          <street>350 Ellis St</street>
          <city>Mountain View</city>
          <region>CA</region>
          <code>94043</code>
          <country>USA</country>
        </postal>
        <email>mingliang_pei@symantec.com</email>
      </address>
    </author>

    <author fullname="Andrew Atyeo" initials="A." surname="Atyeo">
      <organization>Intercede</organization>
      <address>
        <postal>
          <street>St. Mary's Road, Lutterworth</street>
          <city>Leicestershire</city>
          <region>LE17</region>
          <code>4PS</code>
          <country>Great Britain</country>
        </postal>
        <email>andrew.atyeo@intercede.com</email>
      </address>
    </author>

    <author fullname="Hannes Tschofenig" initials="H." surname="Tschofenig">
      <organization>Arm Ltd.</organization>
      <address>
        <postal>
          <street>110 Fulbourn Rd</street>
          <city>Cambridge</city>
          <region>CB1</region>
          <code>9NJ</code>
          <country>Great Britain</country>
        </postal>
        <email>hannes.tschofenig@arm.com</email>
      </address>
    </author>

        <author fullname="David Wheeler" initials="D." surname="Wheeler">
      <organization>Intel</organization>
      <address>
        <postal>
          <street></street>
          <city></city>
          <region></region>
          <code></code>
          <country>US</country>
        </postal>
        <email>david.m.wheeler@intel.com</email>
      </address>
    </author>
       
    <author fullname="David Thaler" initials="D." surname="Thaler">
      <organization>Microsoft</organization>
      <address>
        <postal>
          <street></street>
          <city></city>
          <code></code>
          <country>US</country>
        </postal>
        <email>dthaler@microsoft.com</email>
      </address>
    </author>
    
    <date month="July" year="2019" />
    
    <area>Security</area>
    <workgroup>TEEP</workgroup>
    <keyword>Trusted Execution Environment</keyword>
    <abstract>
      <t>This document specifies the Open Trust Protocol (OTrP) version 2, a
      protocol that provisions and installs, updates, and deletes Trusted Applications 
      in a device with a Trusted Execution Environment (TEE).
      </t>
    </abstract>
  </front>

  <middle>
   <section anchor="introduction" title="Introduction">
      <t>The Trusted Execution Environment (TEE) concept has been designed to
      separate a regular operating system, also referred as a Rich Execution
      Environment (REE), from security-sensitive applications. In an TEE
      ecosystem, different device vendors may use different operating systems in the 
      REE and may use different types of TEEs. When application providers or 
      device administrators use Trusted Application Managers (TAMs) to install, update, 
      and delete Trusted Applications (TAs) on a wide range of devices with potentially 
      different TEEs then an interoperability need arises.</t>
      
      <t>This document specifies version 2 of the Open Trust Protocol (OTrP), a protocol 
      for communicating between an OTrP server (as part of a TAM)  and an OTrP client 
      (which is a client-side component running in the REE).
      </t>

      <t>The Trusted Execution Environment Provisioning (TEEP) architecture
      document <xref target="I-D.ietf-teep-architecture"/> has set to provide a design guidance
      for such an interoperable protocol.
      </t>

    </section>

    <section title="Requirements Language">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in
        <xref target="RFC2119"/>.
      </t>
      <t>This specification re-uses the terminology defined in 
      <xref target="I-D.ietf-teep-architecture" />.</t>
      
    </section>


    <section anchor="messages" title="OTrP Message Overview">
      <t>OTrP consists of a couple of messages exchanged between a TAM and an OTrP Agent via an OTrP Broker. 
      The messages are encoded either in JSON or CBOR and designed to provide end-to-end security. 
      OTrP messages are signed and/or encrypted by the endpoints, i.e., TAM and OTrP Agent, but trusted 
      applications may as well be encrypted and signed by the service provider. OTrP not only re-uses 
      JSON and CBOR but also the respective security wrappers, namely JOSE (JWS <xref target="RFC7515"/>
          and JWE <xref target="RFC7516"/>, to be more specific) and COSE. Furthermore, 
      for attestation the Entity Attestation Token (EAT) and for software updates the SUIT 
      manifest format is re-used.
      </t>


        <t>
          This specification defines six messages. 
</t> 

<t>
          
          A TAM queries a device's current state with a QueryRequest message. 
          An OTrP Agent will, after authenticating and authorizing the request, report 
          attestation information, list all TAs, and provide information about supported 
          algorithms and extensions in a QueryResponse message. An error message is returned if the request 
          could not be processed. A TAM will process the QueryResponse message and determine 
          whether subsequent message exchanges to install, update, or delete trusted applications 
          shall be initiated. 
          
          <figure>
            <artwork><![CDATA[          
  +------------+           +-------------+
  | TAM        |           |OTrP Agent   |
  +------------+           +-------------+

    QueryRequest ------->

                           QueryResponse

                 <-------     or

                             Error
           ]]></artwork>
          </figure>
</t> 

<t>
With the TrustedAppInstall message a TAM can instruct an OTrP Agent to install a TA. 
The OTrP Agent will process the message, determine whether the TAM is authorized and whether the 
TA has been signed by an authorized SP. In addition to the binary, the TAM may also provide 
personalization data. If the TrustedAppInstall message was processed successfully then a 
Success message is returned to the TAM, an Error message otherwise. 

          <figure>
            <artwork><![CDATA[                    
 +------------+           +-------------+
 | TAM        |           |OTrP Agent   |
 +------------+           +-------------+

   TrustedAppInstall ---->

                            Success

                    <----    or

                            Error
           ]]></artwork>
          </figure>
</t> 

<t>With the TrustedAppDelete message a TAM can instruct an OTrP Agent to delete one or multiple TA(s). 
A Success message is returned when the operation has been completed successfully, and an Error message
otherwise. 

          <figure>
            <artwork><![CDATA[          
 +------------+           +-------------+
 | TAM        |           |OTrP Agent   |
 +------------+           +-------------+

   TrustedAppDelete  ---->

                            Success

                    <----    or

                            Error
           ]]></artwork>
          </figure>
</t>

    </section>


    <section anchor="detailmsg" title="Detailed Messages Specification">
      <t>For each message in the following sections all JSON elements are
        mandatory if not explicitly indicated as optional.
      </t>
      <section anchor="getdevicestate" title="GetDeviceState">
        <t>
          This is the first command that a TAM will send to a device. This
          command is triggered when an SP's Client Application contacts
          its TAM to check whether the underlying device is ready for TA
          operations.
        </t>
        <t>
          This command queries a device's current TEE state. A device TEE
          will report its version, its FW version, and list of all SDs and
          TAs in the device that is managed by the requesting TAM. TAM may
          determine whether the device is trustworthy and decide to carry
          out additional commands according to the response from this
          query.
        </t>
        <t>
          The request message of this command is signed by the TAM. The
          response message from the TEE is encrypted. A random message
          encryption key (MK) is generated by TEE, and this encrypted key
          is encrypted by the TAM's public key such that only the TAM that
          sent the request is able to decrypt and view the response
          message.
        </t>

        <section anchor="getdsreq" title="GetDeviceStateRequest message">

          <figure>
            <artwork><![CDATA[
{
   "GetDeviceStateTBSRequest": {
      "ver": "1.0",
      "rid": "<Unique request ID>",
      "tid": "<transaction ID>",
      "ocspdat": [<a list of OCSP stapling data>"],
      "supportedsigalgs": [<array of supported signing algorithms>]
    }
}
           ]]></artwork>
          </figure>

          <t>
            The request message consists of the following data elements:
            <list hangIndent="4" style="hanging">
              <t hangText="ver - ">version of the message format</t>
              <t hangText="rid - ">a unique request ID generated by the TAM</t>
              <t hangText="tid - ">a unique transaction ID to trace request and
                response. This can be from a prior transaction's tid field, and
                can be used in  subsequent message exchanges in this TAM
                session. The combination of rid and tid MUST be made unique.
              </t>
              <t hangText="ocspdat - ">A list of OCSP stapling data respectively
                for the TAM certificate and each of the CA certificates up to
                the root certificate. The TAM provides OCSP data such that a
                recipient TEE can validate the TAM certificate chain revocation
                status without making its own external OCSP service call. A TEE
                MAY cache the CA OCSP data such that the array may contain only
                the OCSP stapling data for the TAM certificate in subsequent
                exchanges. This is a mandatory field.
              </t>
              <t hangText="supportedsigalgs - ">an optional property to list
                the signing algorithms that the TAM is able to support. A
                recipient TEE MUST choose an algorithm in this list to sign
                its response message if this property is present in a request.
                If it is absent, the TEE may use any compliant signing algorithm
                that is listed as mandatory support in this specification.
              </t>
            </list>
          </t>

          <figure>
            <preamble>The final request message is JSON signed message
            of the above raw JSON data with TAM's certificate.
            </preamble>

            <artwork><![CDATA[
{
  "GetDeviceStateRequest": {
    "payload": "<BASE64URL encoding of the GetDeviceStateTBSRequest
               JSON above>",
    "protected": "<BASE64URL encoded signing algorithm>",
    "header": {
        "x5c": "<BASE64 encoded TAM certificate chain up to the
                root CA certificate>"
    },
    "signature":"<signature contents signed by TAM private key>"
  }
}
          ]]></artwork>
          </figure>

          <t>The signing algorithm SHOULD use SHA256 with respective key
            type. The mandatory algorithm support is the RSA signing
            algorithm. The signer header "x5c" is used to include the TAM
            signer certificate up to the root CA certificate.
          </t>

        </section>

        <section title="Request processing requirements at a TEE">
          <t> Upon receiving a request message GetDeviceStateRequest at a
          TEE, the TEE MUST validate a request:

            <list hangIndent="2" style="numbers">
              <t>Validate JSON message signing. If it doesn't pass, an error
              message is returned.</t>
              <t>Validate that the request TAM certificate is chained to a
              trusted CA that the TEE embeds as its trust anchor.
                <list hangIndent="2" style="symbols">
                  <t>Cache the CA OCSP stapling data and certificate
                  revocation check status for other subsequent requests.
                  </t>
                  <t>A TEE can use its own clock time for the OCSP stapling
                  data validation. </t>
                </list></t>
              <t>Optionally collect Firmware signed data
                <list hangIndent="2" style="symbols">
                  <t>This is a capability in ARM architecture that allows a
                  TEE to query Firmware to get FW signed data. It isn't required
                  for all TEE implementations. When TFW signed data is absent,
                  it is up to a TAM's policy how it will trust a TEE.</t>
                </list></t>
              <t>Collect SD information for the SD owned by this TAM</t>
            </list>
          </t>
        </section>

        <section title="Firmware Signed Data">
          <t> Firmware isn't expected to process or produce JSON data. It
          is expected to just sign some raw bytes of data.</t>

          <t>The data to be signed by TFW key needs be some unique random
          data each time. The (UTF-8 encoded) "tid" value from the
          GetDeviceStateTBSRequest shall be signed by the firmware. TAM
          isn't expected to parse TFW data except the signature
          validation and signer trust path validation.
          </t>

          <t>It is possible that a TEE can get some valid TFW signed data
          from another device. The TEE is responsible to validate TFW integrity
          to ensure that the underlying device firmware is trustworthy. In
          some cases, a TEE isn't able to get a TFW signed data, in which
          case the TEE trust validation is up to a TAM to decide. A TAM
          may opt to trust a TEE basing on the TEE signer and additional
          information about a TEE out-of-band.
          </t>

          <t>When TFW signed data is available, a TAM validates the TEE and
            trusts that a trusted TEE has carried out appropriate trust check
            about a TFW.
          </t>

          <figure>
            <artwork><![CDATA[
  TfwData: {
       "tbs": "<TFW to be signed data, BASE64 encoded>",
       "cert": "<BASE64 encoded TFW certificate>",
       "sigalg": "Signing method",
       "sig": "<TFW signed data,  BASE64 encoded>"
  }
           ]]></artwork>
          </figure>

          <t>It is expected that a FW uses standard signature methods for
          maximal interoperability with TAM providers. The mandatory
          support list of signing algorithm is RSA with SHA256.
          </t>

          <t>The JSON object above is constructed by a TEE with data
          returned from the FW. It isn't a standard JSON signed object. The
          signer information and data to be signed must be specially
          processed by a TAM according to the definition given here. The data
          to be signed is the raw data.
          </t>

          <section title="Supported Firmware Signature Methods">
            <t>TAM providers shall support the following signature
            methods. A firmware provider can choose one of the methods in
            signature generation.
              <list hangIndent="2" style="symbols">
                <t>RSA with SHA256</t>
                <t>ECDSA with SHA 256</t>
              </list></t>

            <t>The value of "sigalg" in the TfwData JSON message SHOULD use
               one of the following:
              <list hangIndent="2" style="symbols">
                <t>RS256</t>
                <t>ES256</t>
              </list>
            </t>
          </section>
        </section>

        <section title="Post Conditions">
          <t>Upon successful request validation, the TEE information is
          collected. There is no change in the TEE in the device.
          </t>

          <t>The response message shall be encrypted where the encryption
          key shall be a symmetric key that is wrapped by TAM's public
          key. The JSON Content Encryption Key (CEK) is used for this
          purpose.
          </t>
        </section>

        <section anchor="getdsresp" title="GetDeviceStateResponse Message">
          <t>The message has the following structure.</t>
          <figure>
            <artwork><![CDATA[
  {
    "GetDeviceTEEStateTBSResponse": {
        "ver": "1.0",
        "status": "pass | fail",
        "rid": "<the request ID from the request message>",
        "tid": "<the transaction ID from the request message>",
        "signerreq": true | false // about whether TAM needs to send
                      signer data again in subsequent messages,
        "edsi": "<Encrypted JSON DSI information>"
    }
 }
           ]]></artwork>
          </figure>

          <t>
            where
            <list hangIndent="4" style="hanging">
              <t hangText="signerreq - ">true if the TAM should send its
              signer certificate and OCSP data again in the subsequent
              messages. The value may be "false" if the TEE caches the
              TAM's signer certificate and OCSP status.</t>
              <t hangText="rid - ">the request ID from the request message</t>
              <t hangText="tid - ">the tid from the request message</t>
              <t hangText="edsi - ">the main data element whose value is
              JSON encrypted message over the following Device State
              Information (DSI).</t>
            </list>
          </t>


          <t>The Device State Information (DSI) message consists of the
          following.</t>
<t>
          <figure>
            <artwork><![CDATA[
{
    "dsi": {
        "tfwdata": {
            "tbs": "<TFW to be signed data is the tid>"
            "cert": "<BASE64 encoded TFW certificate>",
            "sigalg": "Signing method",
            "sig": "<TFW signed data, BASE64 encoded>"
        },
        "tee": {
            "name": "<TEE name>",
            "ver": "<TEE version>",
            "cert": "<BASE64 encoded TEE cert>",
            "cacert": "<JSON array value of CA certificates up to
                        the root CA>",
            "sdlist": {
                "cnt": "<Number of SD owned by this TAM>",
                "sd": [
                    {
                        "name": "<SD name>",
                        "spid": "<SP owner ID of this SD>",
                        "talist": [
                          {
                             "taid": "<TA application identifier>",
                             "taname": "<TA application friendly
                                       name>" // optional
                          }
                        ]
                    }
                ]
            },
            "teeaiklist": [
                {
                    "spaik": "<SP AIK public key, BASE64 encoded>",
                    "spaiktype": "<RSA | ECC>",
                    "spid": "<sp id>"
                }
            ]
        }
    }
}
           ]]></artwork>
          </figure>
</t>

          <t>The encrypted JSON message looks like the following.</t>

          <figure>
            <artwork><![CDATA[
{
    "protected": "<BASE64URL encoding of encryption algorithm header
                   JSON data>",
    "recipients": [
        {
            "header": {
                "alg": "RSA1_5"
            },
            "encrypted_key": "<encrypted value of CEK>"
        }
    ],
    "iv": "<BASE64URL encoded IV data>",
    "ciphertext": "<Encrypted data over the JSON object of dsi
                    (BASE64URL)>",
    "tag": "<JWE authentication tag (BASE64URL)>"
}
           ]]></artwork>
          </figure>

          <t>Assume we encrypt plaintext with AES 128 in CBC mode with
          HMAC SHA 256 for integrity, the encryption algorithm header is:
            <list hangIndent="4" style="empty">
              <t>{"enc":"A128CBC-HS256"}</t>
            </list>
          </t>

          <t>The value of the property "protected" in the above JWE
          message will be
            <list hangIndent="4" style="empty">
              <t>eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0</t>
            </list>
          </t>

          <t>In other words, the above message looks like the following:</t>
          <figure>
            <artwork><![CDATA[
{
    "protected": "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0",
     "recipients": [
        {
            "header": {
                "alg": "RSA1_5"
            },
            "encrypted_key": "<encrypted value of CEK>"
        }
    ],
    "iv": "<BASE64URL encoded IV data>",
    "ciphertext": "<Encrypted data over the JSON object of dsi
                    (BASE64URL)>",
    "tag": "<JWE authentication tag (BASE64URL)>"
}
           ]]></artwork>
          </figure>

          <t>The full response message looks like the following:</t>
          <figure>
            <artwork><![CDATA[
{
  "GetDeviceTEEStateTBSResponse": {
    "ver": "1.0",
    "status": "pass | fail",
    "rid": "<the request ID from the request message>",
    "tid": "<the transaction ID from the request message>",
    "signerreq": "true | false",
    "edsi": {
      "protected": "<BASE64URL encoding of encryption algorithm
                     header JSON data>",
      "recipients": [
        {
          "header": {
            "alg": "RSA1_5"
          },
          "encrypted_key": "<encrypted value of CEK>"
        }
      ],
      "iv": "<BASE64URL encoded IV data>",
      "ciphertext": "<Encrypted data over the JSON object of dsi
                      (BASE64URL)>",
      "tag": "<JWE authentication tag (BASE64URL)>"
    }
  }
}
           ]]></artwork>
          </figure>

          <t>The CEK will be encrypted by the TAM public key in the
          device. The TEE signed message has the following structure.</t>
          <figure>
            <artwork><![CDATA[
{
  "GetDeviceTEEStateResponse": {
    "payload": "<BASE64URL encoding of the JSON message
                 GetDeviceTEEStateTBSResponse>",
    "protected": "<BASE64URL encoding of signing algorithm>",
    "signature": "<BASE64URL encoding of the signature value>"
  }
}
           ]]></artwork>
          </figure>

          <t>The signing algorithm shall use SHA256 with respective key
          type, see <xref target="signalgs"></xref>.
          </t>
          <t>The final GetDeviceStateResponse response message consists
          of an array of TEE responses.
          </t>

          <figure>
            <artwork><![CDATA[
{
    "GetDeviceStateResponse": [ // JSON array
       {"GetDeviceTEEStateResponse": ...},
       ...
       {"GetDeviceTEEStateResponse": ...}
    ]
}
           ]]></artwork>
          </figure>
        </section>

        <section title="Error Conditions">
          <t>An error may occur if a request isn't valid or the TEE runs
            into some error. The list of possible error conditions is the
            following.
            <list hangIndent="2" style="hanging">
            <t hangText="ERR_REQUEST_INVALID">The TEE meets the following
            conditions with a request message: (1) The request from a TAM
            has an invalid message structure; mandatory information is
            absent in the message; or an undefined member or structure is
            included.  (2) TEE fails to verify the signature of the message
            or fails to decrypt its contents.</t>
            <t hangText="ERR_UNSUPPORTED_MSG_VERSION">The TEE receives a
            version of message that the TEE can't deal with.</t>
            <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG">The TEE receives a
            request message encoded with a cryptographic algorithm that
            the TEE doesn't support.</t>
            <t hangText="ERR_TFW_NOT_TRUSTED">The TEE considers the
            underlying device firmware be not trustworthy.</t>
            <t hangText="ERR_TAM_NOT_TRUSTED">The TEE needs to make sure
            whether the TAM is trustworthy by checking the validity of
            the TAM certificate and OCSP stapling data and so on. If the TEE
            finds the TAM is not reliable, it returns this error code.</t>
            <t hangText="ERR_TEE_FAIL">If the TEE fails to
            process a request because of its internal error but is able
            to sign an error response message, it will return this error
            code.</t>
          </list></t>

          <t>The response message will look like the following if the TEE
          signing can work to sign the error response message.
          </t>
          <figure>
            <artwork><![CDATA[
  {
      "GetDeviceTEEStateTBSResponse": {
          "ver": "1.0",
          "status": "fail",
          "rid": "<the request ID from the request message>",
          "tid": "<the transaction ID from the request message>",
          "reason": {"error-code":"<error code>"}
          "supportedsigalgs": [<an array of signature algorithms that
                               the TEE supports>]
      }
  }
           ]]></artwork>
          </figure>

          <t>where
            <list hangIndent="4" style="hanging">
              <t hangText="supportedsigalgs -">an optional property to
              list the JWS signing algorithms that the active TEE
              supports. When a TAM sends a signed message that the TEE isn't
              able to validate, it can include signature algorithms that
              it is able to consume in this status report. A TAM can
              generate a new request message to retry the management task
              with a TEE-supported signing algorithm.</t>
            </list></t>

          <t>If the TEE isn't able to sign an error message due to an internal
            device error, a general error message should be returned by
            the OTrP Broker.
          </t>
        </section>

        <section title="TAM Processing Requirements">
          <t>Upon receiving a GetDeviceStateResponse message
          at a TAM, the TAM MUST validate the following.
            <list hangIndent="2" style="symbols">
              <t>Parse to get list of GetDeviceTEEStateResponse JSON
              objects</t>
              <t>Parse the JSON "payload" property and decrypt the JSON
              element "edsi". The decrypted message contains the TEE signer
              certificate.</t>
              <t>Validate the GetDeviceTEEStateResponse JSON signature. The
              signer certificate is extracted from the decrypted message
              in the last step.</t>
              <t>Extract TEE information and check it against its TEE
              acceptance policy.</t>
              <t>Extract the TFW signed element, and check the signer and
              data integration against its TFW policy.</t>
              <t>Check the SD list and TA list and prepare for a
              subsequent command such as "CreateSD" if it needs to have a
              new SD for an SP.</t>
            </list>
          </t>
        </section>

      </section> <!-- Get Device State -->

      <section anchor="tamgmt" title="Trusted Application Management">
        <t>This protocol doesn't introduce a TA container concept. All
        TA authorization and management will be up to the TEE
        implementation.
        </t>

        <t>The following three TA management commands are supported.
            <list hangIndent="2" style="symbols">
              <t>InstallTA - provision a TA by TAM</t>
              <t>UpdateTA - update a TA by TAM</t>
              <t>DeleteTA - remove TA registration information with an SD,
              remove the TA binary and all TA-related data in
              a TEE</t>
            </list>
        </t>

        <section anchor="installta" title="InstallTA">
          <t>TA binary data and related personalization data if there is any
            can be from two sources:
            <list hangIndent="2" style="numbers">
              <t>A TAM supplies the signed and encrypted TA binary</t>
              <t>A Client Application supplies the TA binary</t>
            </list>
          </t>

          <t>This specification primarily considers the first case where a TAM
          supplies a TA binary. This is to ensure that a TEE can properly
          validate whether a TA is trustworthy. Further, TA personalization data
          will be encrypted by the TEE device's SP public key for end-to-end
          protection. A Client Application bundled TA case will be addressed
          separately later.</t>

          <t>A TAM sends the following information in a
          InstallTARequest message to a target TEE:
            <list hangIndent="2" style="symbols">
              <t>The target SD information: SP ID and SD name</t>
              <t>Encrypted TA binary data. TA data is encrypted with the TEE
              SP AIK.</t>
              <t>TA metadata. It is optional to include the SP signer certificate
              for the SD to add if the SP has changed signer since the SD
              was created.</t>
            </list>
          </t>

          <t>The TEE processes the command given by the TAM to install a TA
            into an SP's SD. It does the following:
            <list hangIndent="2" style="symbols">
              <t>Validation
                <list hangIndent="2" style="symbols">
                  <t>The TEE validates the TAM message authenticity</t>
                  <t>Decrypt to get request content</t>
                  <t>Look up the SD with the SD name</t>
                  <t>Checks that the TAM owns the SD</t>
                  <t>Checks that the DSI hash matches which shows that the
                    device state hasn't changed</t>
                </list>
              </t>
              <t>If the request is valid, continue to do the TA validation
                <list hangIndent="2" style="symbols">
                  <t>Decrypt to get the TA binary data and any personalization
                  data with the "TEE SP AIK private key"</t>
                  <t>Check that SP ID is the one that is registered with
                  the SP SD</t>
                  <t>Check that the TA signer is either a newly given SP
                    certificate or the one that is already trusted by the
                    SD from the previous TA installation. The TA signing
                    method is specific to a TEE. This specification doesn't
                    define how a TA should be signed; a TAM should support
                    TEE specific TA signing when it supports that TEE.</t>
                  <t>If a TA signer is given in the request, add this
                  signer into the SD.</t>
                </list>
              </t>
              <t>If the above validation passed, continue to do TA installation
                <list hangIndent="2" style="symbols">
                  <t>The TEE re-encrypts the TA binary and its personalization
                  data with its own method.</t>
                  <t>The TEE enrolls and stores the TA in a secure
                  storage.</t>
                </list>
              </t>
              <t>Construct a response message. This involves signing
              encrypted status information for the requesting TAM.</t>
            </list>
          </t>

          <section anchor="installtareq" title="InstallTARequest Message">
            <figure>
              <preamble>The request message for InstallTA has the
              following JSON format.</preamble>
              <artwork><![CDATA[
{
  "InstallTATBSRequest": {
    "ver": "1.0",
    "rid": "<unique request ID>",
    "tid": "<transaction ID>",
    "tee": "<TEE routing name from the DSI for the SD's target>",
    "nextdsi": true | false,
    "dsihash": "<hash of DSI returned in the prior query>",
    "content": ENCRYPTED {
      "tamid": "<TAM ID previously assigned to the SD>",
      "spid": "<SPID value>",
      "sdname": "<SD name for the domain to install the TA>",
      "spcert": "<BASE64 encoded SP certificate >", // optional
      "taid": "<TA identifier>"
    },
    "encrypted_ta": {
      "key": "<JWE enveloped data of a 256-bit symmetric key by
               the recipient's TEEspaik public key>",
      "iv": "<hex of 16 random bytes>",
      "alg": "<encryption algoritm. AESCBC by default.",
      "ciphertadata": "<BASE64 encoded encrypted TA binary data>",
      "cipherpdata": "<BASE64 encoded encrypted TA personalization
                      data>"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the message, <list hangIndent="2" style="hanging">
              <t hangText="rid -"> A unique value to identify this
              request</t>
              <t hangText="tid -"> A unique value to identify this
              transaction. It can have the same value for the tid in the
              preceding GetDeviceStateRequest.</t>
              <t hangText="tee -"> TEE ID returned from the previous
              GetDeviceStateResponse </t>
              <t hangText="nextdsi -"> Indicates whether the up-to-date
              Device State Information (DSI) is to be returned in the
              response to this request.</t>
              <t hangText="dsihash -"> The BASE64-encoded SHA256 hash
              value of the DSI data returned in the prior TAM operation
              with this target TEE. This value is always included such
              that a receiving TEE can check whether the device state has
              changed since its last query. It helps enforce SD update
              order in the right sequence without accidentally overwriting an
              update that was done simultaneously.</t>
              <t hangText="content -"> The "content" is a JSON encrypted
              message that includes actual input for the SD update. The
              standard JSON content encryption key (CEK) is used, and the
              CEK is encrypted by the target TEE's public key.</t>
              <t hangText="tamid -"> SD owner claim by TAM - An SD owned
              by a TAM will be associated with a trusted identifier
              defined as an attribute in the signer TAM certificate.</t>
              <t hangText="spid -"> SP identifier of the TA owner SP</t>
              <t hangText="sdname -"> the name of the target SD where the
              TA is to be installed</t>
              <t hangText="spcert -"> an optional field to specify the SP
              certificate that signed the TA. This is sent if the SP has
              a new certificate that hasn't been previously registered
              with the target SD where the TA should be installed.</t>
              <t hangText="taid -"> the identifier of the TA application
              to be installed</t>
              <t hangText="encrypted_ta -"> the message portion contains
              encrypted TA binary data and personalization data. The TA
              data encryption key is placed in "key", which is encrypted
              by the recipient's public key, using JWE enveloped structure.
              The TA data encryption uses symmetric key based encryption
              such as AESCBC.</t>
            </list></t>

            <figure>
              <preamble>According to the OTrP message template, the full
              request InstallTARequest is a signed message over the
              InstallTATBSRequest as follows.
              </preamble>

              <artwork><![CDATA[
{
    "InstallTARequest": {
        "payload": "<InstallTATBSRequest JSON above>",
        "protected": "<integrity-protected header contents>",
        "header": "<non-integrity-protected header contents>",
        "signature": "<signature contents signed by TAM private key>"
    }
}
             ]]></artwork>
            </figure>
          </section>

          <section anchor="installtaresp" title="InstallTAResponse Message">
            <t>The response message for a InstallTARequest contains the
            following content.</t>

            <figure>
              <artwork><![CDATA[
{
  "InstallTATBSResponse": {
    "ver": "1.0",
    "status": "<operation result>",
    "rid": "<the request ID received>",
    "tid": "<the transaction ID received>",
    "content": ENCRYPTED {
      "reason":"<failure reason detail>", // optional
      "did": "<the device id hash>",
      "dsi": "<Updated TEE state, including all SD owned by
        this TAM>"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the response message, the following fields MUST be supplied.
             <list hangIndent="2" style="hanging">
              <t hangText="did - "> the SHA256 hash of the device TEE
              certificate. This shows the device ID explicitly to the
              receiving TAM.</t>
             </list>
            </t>

            <t>The final message InstallTAResponse looks like the
            following.</t>

            <figure>
              <artwork><![CDATA[
{
    "InstallTAResponse": {
        "payload":"<InstallTATBSResponse JSON above>",
        "protected": {
            "<BASE64URL of signing algorithm>"
        },
        "signature": "<signature contents signed by TEE device
          private key (BASE64URL)>"
    }
}

             ]]></artwork>
            </figure>

            <t>When the TEE fails to respond, the OTrP Broker will not provide
              a subsequent response to the TAM. The TAM should treat this as
              if the device has gone offline where a response is never
              delivered back.</t>
          </section>

          <section anchor="installtaerrors" title="Error Conditions">
            <t>An error may occur if a request isn't valid or the TEE
            runs into some error. The list of possible errors are as follows.
            Refer to the <xref target="errorcodelist">
            Error Code List</xref> for detailed causes and actions.

              <list hangIndent="2" style="hanging">
                <t hangText="ERR_REQUEST_INVALID"></t>
                <t hangText="ERR_UNSUPPORTED_MSG_VERSION"></t>
                <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG"></t>
                <t hangText="ERR_DEV_STATE_MISMATCH"></t>
                <t hangText="ERR_SD_NOT_FOUND"></t>
                <t hangText="ERR_TA_INVALID"></t>
                <t hangText="ERR_TA_ALREADY_INSTALLED"></t>
                <t hangText="ERR_TEE_FAIL"></t>
                <t hangText="ERR_TEE_RESOURCE_FULL"></t>
                <t hangText="ERR_TAM_NOT_AUTHORIZED"></t>
                <t hangText="ERR_TAM_NOT_TRUSTED"></t>
              </list>
            </t>
          </section>
        </section> <!-- install TA -->

        <section anchor="updateta" title="UpdateTA">
          <t>This TAM-initiated command can update a TA and its data in an
          SP's SD that it manages for the following purposes.
            <list hangIndent="2" style="numbers">
              <t>Update TA binary</t>
              <t>Update TA's personalization data</t>
            </list>
          </t>

          <t>The TAM presents the proof of the SD ownership to a TEE, and
          includes related information in its signed message. The entire
          request is also encrypted for end-to-end confidentiality.</t>

          <t>The TEE processes the command from the TAM to update the TA of
            an SP SD. It does the following:
            <list hangIndent="2" style="symbols">
              <t>Validation
                <list hangIndent="2" style="symbols">
                  <t>The TEE validates the TAM message authenticity</t>
                  <t>Decrypt to get request content</t>
                  <t>Look up the SD with the SD name</t>
                  <t>Checks that the TAM owns the SD</t>
                  <t>Checks DSI hash matches that the device state hasn't
                  changed</t>
                </list>
              </t>
              <t>TA validation
                <list hangIndent="2" style="symbols">
                  <t>Both TA binary and personalization data are
                  optional, but at least one of them shall be present in
                  the message</t>
                  <t>Decrypt to get the TA binary and any personalization
                  data with the "TEE SP AIK private key"</t>
                  <t>Check that SP ID is the one that is registered with
                  the SP SD</t>
                  <t>Check that the TA signer is either a newly given SP certificate
                  or the one in SD.</t>
                  <t>If a TA signer is given in the request, add this
                  signer into the SD.</t>
                </list>
              </t>
              <t>If the above validation passes, continue to do TA update
                <list hangIndent="2" style="symbols">
                  <t>The TEE re-encrypts the TA binary and its personalization
                  data with its own method</t>
                  <t>The TEE replaces the existing TA binary and its
                  personalization data with the new binary and data.</t>
                </list>
              </t>
              <t>Construct a response message. This involves signing a
              encrypted status information for the requesting TAM.</t>
            </list>
          </t>

          <section anchor="updatetareq" title="UpdateTARequest Message">
            <figure>
              <preamble>The request message for UpdateTA has the
              following JSON format.</preamble>
              <artwork><![CDATA[
{
  "UpdateTATBSRequest": {
    "ver": "1.0",
    "rid": "<unique request ID>",
    "tid": "<transaction ID>",
    "tee": "<TEE routing name from the DSI for the SD's target>",
    "nextdsi": true | false,
    "dsihash": "<hash of DSI returned in the prior query>",
    "content": ENCRYPTED {
      "tamid": "<TAM ID previously assigned to the SD>",
      "spid": "<SPID value>",
      "sdname": "<SD name for the domain to be created>",
      "spcert": "<BASE64 encoded SP certificate >", // optional
      "taid": "<TA identifier>"
    },
    "encrypted_ta": {
      "key": "<JWE enveloped data of a 256-bit symmetric key by
               the recipient's TEEspaik public key>",
      "iv": "<hex of 16 random bytes>",
      "alg": "<encryption algoritm. AESCBC by default.",
      "ciphernewtadata": "<Change existing TA binary to this new TA
          binary data(BASE64 encoded and encrypted)>",
      "ciphernewpdata": "<Change the existing data to this new TA
          personalization data(BASE64 encoded and encrypted)>"
          // optional
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the message, <list hangIndent="2" style="hanging">
              <t hangText="rid -"> A unique value to identify this
              request</t>
              <t hangText="tid -"> A unique value to identify this
              transaction. It can have the same value for the tid in the
              preceding GetDeviceStateRequest.</t>
              <t hangText="tee -"> TEE ID returned from the previous
              GetDeviceStateResponse </t>
              <t hangText="nextdsi -"> Indicates whether the up-to-date
              Device State Information (DSI) is to be returned in the
              response to this request.</t>
              <t hangText="dsihash -"> The BASE64-encoded SHA256 hash
              value of the DSI data returned in the prior TAM operation
              with this target TEE. This value is always included such
              that a receiving TEE can check whether the device state has
              changed since its last query. It helps enforce SD update
              order in the right sequence without accidentally overwriting an
              update that was done simultaneously.</t>
              <t hangText="content -"> The "content" is a JSON encrypted
              message that includes actual input for the SD update. The
              standard JSON content encryption key (CEK) is used, and the
              CEK is encrypted by the target TEE's public key.</t>
              <t hangText="tamid -"> SD owner claim by TAM - an SD owned
              by a TAM will be associated with a trusted identifier
              defined as an attribute in the signer TAM certificate.</t>
              <t hangText="spid -"> SP identifier of the TA owner SP</t>
              <t hangText="spcert -"> an optional field to specify the SP
              certificate that signed the TA. This is sent if the SP has
              a new certificate that hasn't been previously registered
              with the target SD where the TA is to be installed.</t>
              <t hangText="sdname -"> the name of the target SD where the
              TA should be updated</t>
              <t hangText="taid -"> an identifier for the TA application
              to be updated</t>
              <t hangText="encrypted_ta -"> the message portion contains
              newly encrypted TA binary data and personalization data.</t>
            </list></t>

            <figure>
              <preamble>According to the OTrP message template, the full
              request UpdateTARequest is a signed message over the
              UpdateTATBSRequest as follows.
              </preamble>

              <artwork><![CDATA[


{
    "UpdateTARequest": {
        "payload": "<UpdateTATBSRequest JSON above>",
        "protected": "<integrity-protected header contents>",
        "header": "<non-integrity-protected header contents>",
        "signature": "<signature contents signed by TAM private key>"
    }
}
             ]]></artwork>
            </figure>
          </section>

          <section anchor="updatetaresp" title="UpdateTAResponse Message">
            <t>The response message for a UpdateTARequest contains the
            following content.</t>

            <figure>
              <artwork><![CDATA[
{
  "UpdateTATBSResponse": {
    "ver": "1.0",
    "status": "<operation result>",
    "rid": "<the request ID received>",
    "tid": "<the transaction ID received>",
    "content": ENCRYPTED {
      "reason": "<failure reason detail>", // optional
      "did": "<the device id hash>",
      "dsi": "<Updated TEE state, including all SD owned by
        this TAM>"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the response message, the following fields MUST be supplied.
             <list hangIndent="2" style="hanging">
              <t hangText="did - "> the SHA256 hash of the device TEE
              certificate. This shows the device ID explicitly to the
              receiving TAM.</t>
             </list>
            </t>

            <t>The final message UpdateTAResponse looks like the
            following.</t>

            <figure>
              <artwork><![CDATA[
{
    "UpdateTAResponse": {
        "payload":"<UpdateTATBSResponse JSON above>",
        "protected": {
            "<BASE64URL of signing algorithm>"
        },
        "signature": "<signature contents signed by TEE device
          private key (BASE64URL)>"
    }
}

             ]]></artwork>
            </figure>

            <t>When the TEE fails to respond, the OTrP Broker will not provide
              a subsequent response to the TAM. The TAM should treat this as
              if the device has gone offline where a response is never
              delivered back.</t>
          </section>

          <section anchor="updatetaerrors" title="Error Conditions">
            <t>An error may occur if a request isn't valid or the TEE
            runs into some error. The list of possible errors are as follows.
            Refer to the <xref target="errorcodelist">
            Error Code List</xref> for detailed causes and actions.

              <list hangIndent="2" style="hanging">
                <t hangText="ERR_REQUEST_INVALID"></t>
                <t hangText="ERR_UNSUPPORTED_MSG_VERSION"></t>
                <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG"></t>
                <t hangText="ERR_DEV_STATE_MISMATCH"></t>
                <t hangText="ERR_SD_NOT_FOUND"></t>
                <t hangText="ERR_TA_INVALID"></t>
                <t hangText="ERR_TA_NOT_FOUND"></t>
                <t hangText="ERR_TEE_FAIL"></t>
                <t hangText="ERR_TAM_NOT_AUTHORIZED"></t>
                <t hangText="ERR_TAM_NOT_TRUSTED"></t>
              </list>
            </t>
          </section>
        </section> <!-- update TA -->

        <section anchor="deleteta" title="DeleteTA">
          <t>This operation defines OTrP messages that allow a TAM
          to instruct a TEE to delete a TA for an SP in a given SD. A TEE
          will delete a TA from an SD and also TA data in the TEE.
          A Client Application cannot directly access TEE or OTrP
          Broker to delete a TA.
          </t>

          <section anchor="deletetareq" title="DeleteTARequest Message">
            <figure>
              <preamble>The request message for DeleteTA has the
              following JSON format.</preamble>
              <artwork><![CDATA[
{
  "DeleteTATBSRequest": {
    "ver": "1.0",
    "rid": "<unique request ID>",
    "tid": "<transaction ID>",
    "tee": "<TEE routing name from the DSI for the SD's target>",
    "nextdsi": true | false,
    "dsihash": "<hash of DSI returned in the prior query>",
    "content": ENCRYPTED {
      "tamid": "<TAM ID previously assigned to the SD>",
      "sdname": "<SD name of the TA>",
      "taid": "<the identifier of the TA to be deleted from the
               specified SD>"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the message, <list hangIndent="2" style="hanging">
              <t hangText="rid -"> A unique value to identify this
              request</t>
              <t hangText="tid -"> A unique value to identify this
              transaction. It can have the same value for the tid in the
              preceding GetDeviceStateRequest.</t>
              <t hangText="tee -"> The TEE ID returned from the previous
              GetDeviceStateResponse </t>
              <t hangText="nextdsi -"> Indicates whether the up-to-date
              Device State Information (DSI) is to be returned in the
              response to this request.</t>
              <t hangText="dsihash -"> The BASE64-encoded SHA256 hash
              value of the DSI data returned in the prior TAM operation
              with this target TEE. This value is always included such
              that a receiving TEE can check whether the device state has
              changed since its last query. It helps enforce SD update
              order in the right sequence without accidentally overwriting an
              update that was done simultaneously.</t>
              <t hangText="content -"> The "content" is a JSON encrypted
              message that includes actual input for the SD update. The
              standard JSON content encryption key (CEK) is used, and the
              CEK is encrypted by the target TEE's public key.</t>
              <t hangText="tamid -"> SD owner claim by TAM - an SD owned
              by a TAM will be associated with a trusted identifier
              defined as an attribute in the signer TAM certificate.</t>
              <t hangText="sdname -"> the name of the target SD where the
              TA is installed</t>
              <t hangText="taid -"> an identifier for the TA application
              to be deleted</t>
            </list></t>

            <figure>
              <preamble>According to the OTrP message template, the full
              request DeleteTARequest is a signed message over the
              DeleteTATBSRequest as follows.
              </preamble>

              <artwork><![CDATA[


{
    "DeleteTARequest": {
        "payload": "<DeleteTATBSRequest JSON above>",
        "protected": "<integrity-protected header contents>",
        "header": "<non-integrity-protected header contents>",
        "signature": "<signature contents signed by TAM
            private key>"
    }
}
             ]]></artwork>
            </figure>
          </section>

          <section anchor="deletetareqproc"
            title="Request Processing Requirements at a TEE">

            <t>A TEE processes a command from a TAM to delete a TA of an SP
            SD. It does the following:
             <list hangIndent="2" style="numbers">
              <t>Validate the JSON request message
                <list hangIndent="2" style="symbols">
                  <t>The TEE validates TAM message authenticity</t>
                  <t>Decrypt to get request content</t>
                  <t>Look up the SD and the TA with the given SD name and
                  TA ID</t>
                  <t>Checks that the TAM owns the SD, and TA is installed
                  in the SD</t>
                  <t>Checks that the DSI hash matches and the the device state
                    hasn't changed</t>
                </list>
              </t>
              <t>Deletion action
                <list hangIndent="2" style="symbols">
                  <t>If all the above validation points pass, the TEE
                  deletes the TA from the SD</t>
                  <t>The TEE SHOULD also delete all personalization data for
                  the TA</t>
                </list>
              </t>
              <t>Construct DeleteTAResponse message.</t>
             </list>
            </t>

            <t>If a request is illegitimate or the signature doesn't pass, a
            "status" property in the response will indicate the error
            code and cause.
            </t>

          </section>

          <section anchor="deletetaresp" title="DeleteTAResponse Message">
            <t>The response message for a DeleteTARequest contains the
            following content.</t>

            <figure>
              <artwork><![CDATA[
{
  "DeleteTATBSResponse": {
    "ver": "1.0",
    "status": "<operation result>",
    "rid": "<the request ID received>",
    "tid": "<the transaction ID received>",
    "content": ENCRYPTED {
      "reason": "<failure reason detail>", // optional
      "did": "<the device id hash>",
      "dsi": "<Updated TEE state, including all SD owned by
        this TAM>"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the response message, the following fields MUST be supplied.
             <list hangIndent="2" style="hanging">
              <t hangText="did - "> the SHA256 hash of the device TEE
              certificate. This shows the device ID explicitly to the
              receiving TAM.</t>
             </list>
            </t>

            <t>The final message DeleteTAResponse looks like the
            following.</t>

            <figure>
              <artwork><![CDATA[
{
    "DeleteTAResponse": {
        "payload": "<DeleteTATBSResponse JSON above>",
        "protected": {
            "<BASE64URL of signing algorithm>"
        },
        "signature": "<signature contents signed by TEE device
            private key (BASE64URL)>"
    }
}

             ]]></artwork>
            </figure>

            <t>When the TEE fails to respond, the OTrP Broker will not provide
              a subsequent response to the TAM. The TAM should treat this as
              if the device has gone offline where a response is never
              delivered back.</t>
          </section>

          <section anchor="deletetaerrors" title="Error Conditions">
            <t>An error may occur if a request isn't valid or the TEE
            runs into some error. The list of possible errors are as follows.
            Refer to the <xref target="errorcodelist">
            Error Code List</xref> for detailed causes and actions.

              <list hangIndent="2" style="hanging">
                <t hangText="ERR_REQUEST_INVALID"></t>
                <t hangText="ERR_UNSUPPORTED_MSG_VERSION"></t>
                <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG"></t>
                <t hangText="ERR_DEV_STATE_MISMATCH"></t>
                <t hangText="ERR_SD_NOT_FOUND"></t>
                <t hangText="ERR_TA_NOT_FOUND"></t>
                <t hangText="ERR_TEE_FAIL"></t>
                <t hangText="ERR_TAM_NOT_AUTHORIZED"></t>
                <t hangText="ERR_TAM_NOT_TRUSTED"></t>
              </list>
            </t>
          </section>
        </section> <!-- delete TA -->

      </section>

    </section>

    <section anchor="TAMuse" title="Response Messages a TAM May Expect">
      <t>A TAM expects some feedback from a remote device when a request
        message is delivered to a device. The following three types of
        responses SHOULD be supplied.
      </t>

      <t><list hangIndent="4" style="hanging">
              <t hangText="Type 1: ">Expect a valid TEE-generated
              response message</t>
      <t>A valid TEE signed response may contain errors detected by a TEE, e.g.
        a TAM is trusted but some TAM-supplied data is missing, for example, SP ID
        doesn't exist. TEE MUST be able to sign and encrypt.
      </t>
      <t>If a TEE isn't able to sign a response, the TEE returns an error to
        the OTrP Broker without giving any other internal information. The OTrP
        Broker will be generating the response.
      </t>
      </list></t>

      <t><list hangIndent="4" style="hanging">
              <t hangText="Type 2: ">
              The OTrP Broker generated error message when TEE fails. OTrP
              Broker errors will be defined in this document.</t>
              <t>A Type 2 message has the following format.</t>
      </list></t>

      <figure>
        <artwork><![CDATA[
      {
        "OTrPBrokerError": {
            "ver": "1.0",
            "rid": "",
            "tid": "",
            "errcode": "ERR_AGENT_TEE_UNKNOWN | ERR_AGENT_TEE_BUSY"
        }
      }
           ]]></artwork>
      </figure>

      <t><list hangIndent="4" style="hanging">
              <t hangText="Type 3: ">
        OTrP Broker itself isn't reachable or fails. A Client Application is
        responsible to handle error and respond the TAM in its own way. This is
        out of scope for this specification.</t>
      </list></t>

    </section>

    <section anchor="basicprofile" title="Basic Protocol Profile">
      <t>This section describes a baseline for interoperability among
      the protocol entities, mainly, the TAM and TEE.</t>

      <t>A TEE MUST support RSA algorithms. It is optional to support
      ECC algorithms. A TAM SHOULD use a RSA certificate for TAM message
      signing. It may use an ECC certificate if it detects that the TEE
      supports ECC according to the field "supportedsigalgs" in a TEE
      response.</t>

      <t>A TAM MUST support both RSA 2048-bit algorithm and ECC P-256
      algorithms. With this, a TEE and TFW certificate can be either RSA
      or ECC type. </t>

      <t>JSON signing algorithms
        <list hangIndent="2" style="symbols">
          <t>RSA PKCS#1 with SHA256 signing : "RS256"</t>
          <t>ECDSA with SHA256 signing : "ES256"</t>
        </list>
      </t>

      <t>JSON asymmetric encryption algorithms (describes key-exchange
      or key-agreement algorithm for sharing symmetric key with TEE):
        <list hangIndent="2" style="symbols">
          <t>RSA PKCS#1  : "RSA1_5"</t>
          <t>ECDH using TEE ECC P-256 key and ephemeral ECC key
             generated by TAM : "ECDH-ES+A128W"</t>
        </list>
      </t>

      <t>JSON symmetric encryption algorithms (describes symmetric
      algorithm for encrypting body of data, using symmetric key
      transferred to TEE using asymmetric encryption):
        <list hangIndent="2" style="symbols">
          <t>Authenticated encryption AES 128 CBC with SHA256 :
             {"enc":"A128CBC-HS256"}</t>
        </list>
      </t>
    </section>

    <section anchor="impl" title="Attestation Implementation Consideration">
      <!-- NOTE: this section could be moved to Appendix in RFC -->
      <t>
        It is important to know that the state of a device is appropriate
        before trusting that a device is what it says it is. The attestation
        scheme for OTrP must also be able to cope with different TEEs,
        including those that are OTrP
        compliant and those that use another mechanism. In the initial
        version, only one active TEE is assumed.
      </t>
      <t>
        It is out of scope how the TAM and the device implement the trust
        hierarchy verification. However, it is helpful to understand what each
        system provider should do in order to properly implement an OTrP trust
        hierarchy.
      </t>
      <t>
        In this section, we provide some implementation reference
        consideration.
      </t>

      <section anchor="otrptfw" title="OTrP Trusted Firmware">
        <section anchor="attestsigner" title="Attestation signer">
          <t>
            It is proposed that attestation for OTrP is based on the TFW
            layer, and that further attestation is not
            performed within the TEE itself during Security Domain
            operations. The rationale is that the device boot process
            will be defined to start with a secure bootloader protected
            with a harden key in eFUSE. The process releases attestation
            signing capabilities into the TFW once a trust boot has been
            established. In this way the release of the attestation signer
            can be considered
            the first "platform configuration metric", using Trust Computing
            Group (TCG) terminology.
          </t>
        </section>

        <section anchor="tfwreq" title="TFW Initial Requirements">
          <t>
            <list counter="reqs" hangIndent="4" style="format R%d">
              <t>The TFW must be possible for verification during boot
              </t>
              <t>The TFW must allow a public / private key pair to be generated
                during device manufacture
              </t>
              <t>The public key and certificate must be possible to store
                securely
              </t>
              <t>The private key must be possible to store encrypted at rest
              </t>
              <t>The private key must only be visible to the TFW when it is
                decrypted
              </t>
              <t>The TFW must be able to read a list of root and
              intermediate certificates that it can use to check
              certificate chains with. The list must be stored such that
              it cannot be tampered with
              </t>
              <t>Need to allow a TEE to access its unique TEE
              specific private key
              </t>
            </list>
          </t>
        </section>
      </section>

      <section anchor="teeload" title="TEE Loading">
        <t>During boot, the TFW is required to start all of the root TEEs. Before
        loading them, the TFW must first determine whether the code sign
        signature of the TEE is valid. If TEE integrity is confirmed, the TEE
        may be started. The TFW must then be able to receive the identity certificate
        from the TEE (if that TEE is OTrP compliant). The identity certificate
        and keys will need to be baked into the TEE image, and therefore also
        covered by the code signer hash during the manufacturing process. The
        private key for the identity certificate must be securely protected.
        The private key for a TEE identity must never be released no matter how
        the public key and certificate are released to the TFW.
        </t>
        <t>Once the TFW has successfully booted a TEE and retrieved the
        identity certificate, the TFW will commit this to the platform configuration
        register (PCR) set, for later use during attestation. At minimum, the
        following data must be committed to the PCR for each TEE:
        </t>
        <t>
          <list style="numbers">
            <t>Public key and certificate for the TEE</t>
            <t>TEE identifier that can be used later by a TAM to identify this
              TEE
            </t>
          </list>
        </t>
      </section>

      <section anchor="attest" title="Attestation Hierarchy">
        <t>The attestation hierarchy and seed required for TAM protocol
        operation must be built into the device at manufacture. Additional TEEs
        can be added post-manufacture using the scheme proposed, but it is
        outside of the current scope of this document to detail that.
        </t>
        <t>It should be noted that the attestation scheme described is based on
        signatures. The only decryption that may take place is through the
        use of a bootloader key.
        </t>

        <section title="Attestation Hierarchy Establishment: Manufacture">
          <t>
            During manufacture the following steps are required:
          </t>
          <t>
            <list style="numbers">
              <t>A device-specific TFW key pair and certificate are burnt into
                the device. This key pair will be used for
                signing operations performed by the TFW.
              </t>
              <t>TEE images are loaded and include a TEE instance-specific
                key pair and certificate. The key pair and certificate are included
                in the image and covered by the code signing hash.
              </t>
              <t>The process for TEE images is repeated for any subordinate
                TEEs, which are additional TEEs after the root TEE that some
                devices have.
              </t>
            </list>
          </t>
        </section>

        <section title="Attestation Hierarchy Establishment: Device Boot">
          <t>During device boot the following steps are required:</t>
          <t>
            <list style="numbers">
              <t>The boot module releases the TFW private key by decrypting it with
                the bootloader key.
              </t>
              <t>The TFW verifies the code-signing signature of the active TEE
                 and places its TEE public key into a signing buffer, along with
                 its identifier for later access. For a non-OTrP TEE, the TFW
                 leaves the TEE public key field blank.
              </t>
              <t>The TFW signs the signing buffer with the TFW private key.</t>
              <t>Each active TEE performs the same operation as the TFW, building
                up their own signed buffer containing subordinate TEE
                information.
              </t>
            </list>
          </t>
        </section>

        <section title="Attestation Hierarchy Establishment: TAM">
          <t>Before a TAM can begin operation in the marketplace to support
            devices of a given TEE, it must obtain a TAM certificate from a
            CA that is registered in the trust store of devices with that TEE.
            In this way, the TEE can check the intermediate and root CA and
            verify that it trusts this TAM to perform operations on the TEE.
          </t>
        </section>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>There are two IANA requests: a media type and list of error codes.</t>

      <t>This section first requests that IANA assign a media type:
          application/otrp+json.</t>
        <t>
        <list hangIndent="2" style="hanging">
         <t hangText="Type name:"> application</t>
         <t hangText="Subtype name:"> otrp+json</t>
         <t hangText="Required parameters:"> none</t>
         <t hangText="Optional parameters:"> none</t>
         <t hangText="Encoding considerations:"> Same as encoding considerations of
         application/json as specified in Section 11 of <xref target="RFC7159"/></t>
         <t hangText="Security considerations:"> See Section 12 of <xref target="RFC7159"/>
         and Section 14 of this document</t>
         <t hangText="Interoperability considerations:"> Same as interoperability
         considerations of application/json as specified in
         <xref target="RFC7159"/></t>
         <t hangText="Published specification:"> <xref target="I-D.ietf-teep-architecture"/></t>
         <t hangText="Applications that use this media type:"> OTrP implementations</t>
         <t hangText="Fragment identifier considerations:"> N/A</t>
         <t hangText="Additional information:">
           <list hangIndent="2" style="hanging">
             <t hangText="Deprecated alias names for this type:"> N/A</t>
             <t hangText="Magic number(s):"> N/A</t>
             <t hangText="File extension(s):"> N/A</t>
             <t hangText="Macintosh file type code(s):"> N/A</t>
           </list>
         </t>
         <t hangText="Person to contact for further information:">
            teep@ietf.org</t>
         <t hangText="Intended usage:"> COMMON</t>
         <t hangText="Restrictions on usage:"> none</t>
         <t hangText="Author:"> See the "Authors' Addresses" section of this document</t>
         <t hangText="Change controller:"> IETF</t>
        </list>
        </t>

      <t>The error code listed in the next section will be registered.</t>

      <section anchor="errorcodelist" title="Error Code List">
        <t>This section lists error codes that could be reported by
        a TA or TEE in a device in responding to a TAM request, and a
        separate list that OTrP Broker may return when the TEE fails to
        respond.</t>

        <section anchor="teeerrorcodelist" title="TEE Signed Error Code List">
        <t>
          <list hangIndent="2" style="hanging">
            <t hangText="ERR_DEV_STATE_MISMATCH -"> A TEE will return
            this error code if the DSI hash value from TAM doesn't match
            the has value of the device's current DSI.</t>

            <t hangText="ERR_SD_ALREADY_EXISTS -">  This error will
            occur if an SD to be created already exists in the TEE.</t>

            <t hangText="ERR_SD_NOT_EMPTY -"> This is reported if a
            target SD isn't empty.</t>

            <t hangText="ERR_SDNAME_ALREADY_USED">A TEE will return this
            error code if the new SD name already exists in the TEE.</t>

            <t hangText="ERR_REQUEST_INVALID -"> This error will
            occur if the TEE meets any of the following conditions with a
            request message: (1) The request from a TAM has an
            invalid message structure; mandatory information is
            absent in the message. undefined member or structure is
            included.  (2) TEE fails to verify signature of the
            message or fails to decrypt its contents.</t>

            <t hangText="ERR_SPCERT_INVALID -">  If a new SP
            certificate for the SD to be updated is not valid, then
            the TEE will return this error code.</t>

            <t hangText="ERR_TA_ALREADY_INSTALLED -"> While installing a TA,
            a TEE will return this error if the TA has already been installed
            in the SD.</t>

            <t hangText="ERR_TA_INVALID -"> This error will occur when a TEE
            meets any of following conditions while checking validity of
            TA: (1) The TA binary has a format that the TEE can't recognize. (2)
            The TEE fails to decrypt the encoding of the TA binary and
            personalization data. (3) If an SP isn't registered with the SP SD
            where the TA will be installed.</t>

            <t hangText="ERR_TA_NOT_FOUND -"> This error will occur when
            the target TA doesn't exist in the SD.</t>

            <t hangText="ERR_TEE_FAIL -"> If the TEE fails to process a
              request because of an internal error, it will return this
              error code.</t>

            <t hangText="ERR_TEE_RESOURCE_FULL -"> This error is reported
            when a device resource isn't available anymore such as
            storage space is full.</t>

            <t hangText="ERR_TFW_NOT_TRUSTED -"> A TEE is responsible for
              determining that the underlying device firmware is trustworthy.
              If the TEE determines the TFW is not trustworthy, then
              this error will occur.</t>

            <t hangText="ERR_TAM_NOT_TRUSTED -">  Before processing a
            request, a TEE needs to make sure whether the sender TAM is
            trustworthy by checking the validity of the TAM certificate,
            etc. If the TEE finds that the TAM is not trustworthy, then
            it will return this error code.</t>

            <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG -">  This error
            will occur if a TEE receives a request message encoded with
            cryptographic algorithms that the TEE doesn't support.</t>

            <t hangText="ERR_UNSUPPORTED_MSG_VERSION -">  This error
            will occur if a TEE receives a message version that
            the TEE can't deal with.</t>
          </list>
        </t>
        </section>
      </section>
    </section>

    <section anchor="security" title="Security Consideration">
      <section title="Cryptographic Strength">
        <t>The strength of the cryptographic algorithms, using the measure of
           'bits of security' defined in NIST SP800-57 allowed for OTrP
            is:</t>
        <t><list style="symbols">
         <t>At a minimum, 112 bits of security. The limiting factor for this is
            the RSA-2048 algorithm, which is indicated as providing 112 bits
            of symmetric key strength in
            SP800-57. It is important that RSA is supported in order to enhance
            the interoperability of the protocol.</t>
        <t>The option exists to choose algorithms providing 128 bits of
           security. This requires using TEE devices that support ECC P256.
        </t>
        </list>The available algorithms and key sizes specified in this document
          are based on industry standards.
          Over time the recommended or allowed cryptographic algorithms may
          change. It is important that the OTrP allows for crypto-agility.
          In this specification, TAM and TEE can negotiate an agreed upon
          algorithm where both include their supported algorithm in OTrP
          message.
        </t>
      </section>

      <section title="Message Security">
        <t>OTrP messages between the TAM and TEE are protected by message
        security using JWS and JWE. The 'Basic protocol profile' section of
        this document describes the algorithms used for this. All OTrP TEE
        devices and OTrP TAMs must meet the requirements of the basic profile.
        In the future additional 'profiles' can be added.</t>

        <t>PKI is used to ensure that the TEE will only communicate with a
        trusted TAM, and to ensure that the TAM will only communicate with a
        trusted TEE.</t>
      </section>

      <section title="TEE Attestation">
        <t>It is important that the TAM can trust that it is talking to a
        trusted TEE. This is achieved through attestation. The TEE has a private
        key and certificate built into it at manufacture, which is used to sign
        data supplied by the TAM. This allows the TAM to verify that the TEE is
        trusted. </t>

        <t>It is also important that the TFW (trusted firmware) can be checked.
        The TFW has a private key and certificate built into it at manufacture,
        which allows the TEE to check that that the TFW is trusted. </t>

        <t>The GetDeviceState message therefore allows the TAM to check that it
        trusts the TEE, and the TEE at this point will check whether it trusts
        the TFW. </t>
      </section>

      <section title="TA Protection">
        <t>
          A TA will be delivered in an encrypted form. This encryption is an
          additional layer within the message encryption described in the
          <xref target="basicprofile"/> of this document. The TA binary
          is encrypted for each target device with the device's TEE SP AIK
          public key. A TAM can either do this encryption itself or
          provide the TEE SP AIK public key to an SP such that the SP
          encrypts the encrypted TA for distribution to the TEE.
        </t>

        <figure>
          <preamble>The encryption algorithm can use a random AES 256 key
          "taek" with a 16 byte random IV, and the "taek" is encrypted by the
          "TEE SP AIK public key". The following encrypted TA data structure
          is expected by a TEE: </preamble>

          <artwork><![CDATA[
"encrypted_ta_bin": {
  "key": "<JWE enveloped data of a 256-bit symmetric key by
         the recipient's TEEspaik public key>",
  "iv": <hex of 16 random bytes>",
  "alg": "AESCBC",
  "cipherdata": "<BASE64 encoded encrypted TA binary data>"
}
         ]]></artwork>
        </figure>

      </section>

      <section title="TA Personalization Data">
      <t>
        An SP or TAM can supply personalization data for a TA to initialize for
        a device. Such data is passed through an InstallTA command from a TAM.
        The personalization data itself is (or can be) opaque to the TAM.
        The data can be from the SP without being revealed to the TAM.
        The data is sent in an encrypted manner in a
        request to a device such that only the device can decrypt. A device's
        TEE SP AIK public key for an SP is used to encrypt the data. Here JWE
        enveloping is used to carry all encryption key parameters along with
        encrypted data.
      </t>

        <figure>
          <artwork><![CDATA[
"encrypted_ta_data": { // "TA personalization data"
    "key": "<JWE enveloped data of a 256-bit symmetric key by
             the recipient's TEEspaik public key>",
    "iv": "<hex of 16 random bytes>",
    "alg": "AESCBC",
    "cipherdata": "<BASE64 encoded encrypted TA personalization
                   data>"
  }
         ]]></artwork>
        </figure>

      </section>

      <section title="TA Trust Check at TEE">
        <t>
        A TA binary is signed by a TA signer certificate. This TA signing
        certificate/private key belongs to the SP, and may be self-signed (i.e.,
        it need not participate in a trust hierarchy). It is the responsibility
        of the TAM to only allow verified TAs from trusted SPs into the system.
        Delivery of that TA to the TEE is then the responsibility of the TEE,
        using the security mechanisms provided by the OTrP.
        </t>

        <t>
        We allow a way for an (untrusted) application to check the
        trustworthiness of a TA. OTrP Broker has a function to allow
        a Client Application to query the information about a TA.
        </t>

        <t>
          An application in the Rich O/S may perform verification of the TA by
          verifying the signature of the TA. The GetTAInformation
          function is available to return the TEE supplied TA signer and TAM signer
          information to the application. An application can do additional
          trust checks on the certificate returned for this TA. It might trust
          the TAM, or require additional SP signer trust chaining.
        </t>
      </section>

      <section title="One TA Multiple SP Case">
        <t> A TA for multiple SPs must have a different identifier per SP.
          A TA will be installed in a different SD for each respective SP. </t>
      </section>

      <section title="OTrP Broker Trust Model">
        <t> An OTrP Broker could be malware in the vulnerable REE. A
        Client Application will connect its TAM provider for required TA
        installation. It gets command messages from the TAM, and passes
        the message to the OTrP Broker. </t>

        <t> The OTrP is a conduit for enabling the TAM to communicate
        with the device's TEE to manage SDs and TAs. All TAM messages are
        signed and sensitive data is encrypted such that the OTrP Broker cannot
        modify or capture sensitive data. </t>
      </section>

      <section title="OCSP Stapling Data for TAM Signed Messages">
        <t> The GetDeviceStateRequest message from a TAM to a TEE shall include
        OCSP stapling data for the TAM's signer certificate and for
        intermediate CA certificates up to the root certificate so that the TEE
        can verify the signer certificate's revocation status. </t>

        <t> A certificate revocation status check on a TA signer certificate is
        OPTIONAL by a TEE. A TAM is responsible for vetting a TA and the SP
        before it distributes them to devices. A TEE will
        trust a TA signer certificate's validation status done by a TAM when it
        trusts the TAM. </t>
      </section>

      <section title="Data Protection at TAM and TEE">
        <t> The TEE implementation provides protection of data on the device.
        It is the responsibility of the TAM to protect data on its servers. </t>
      </section>

      <section title="Privacy Consideration">
        <t> Devices are issued with a unique TEE certificate to attest the
          device's validity. This uniqueness also creates a privacy and
          tracking risk that must be mitigated. </t>

        <t> The TEE will only release the TEE certificate to a trusted TAM (it
        must verify the TAM certificate before proceeding). OTrP
        is designed such that only a TAM can obtain the TEE device
        certificate and firmware certificate - the GetDeviceState message
        requires signature checks to validate the TAM is trusted, and OTrP
        delivers the device's certificate(s) encrypted such that only that TAM
        can decrypt the response. A Client Application will never see the
        device certificate. </t>

        <t> An SP-specific TEE SP AIK  (TEE SP Anonymous Key) is generated by
        the protocol for Client Applications. This provides a way for the
        Client Application to validate some data that the TEE may send
        without requiring
        the TEE device certificate to be released to the client device rich O/S
        , and to optionally allow an SP to encrypt a TA for a target device
        without the SP needing to be supplied with the TEE device certificate. </t>
      </section>

      <section title="Threat Mitigation">
        <t> A rogue application may perform excessive TA loading. An OTrP Broker
        implementation should protect against excessive calls. </t>

        <t> Rogue applications might request excessive SD creation. The
        TAM is responsible to ensure this is properly guarded against. </t>

        <t> Rogue OTrP Broker could replay or send TAM messages out of
        sequence: e.g., a TAM sends update1 and update2. The OTrP Broker
        replays update2 and update1 again, creating an unexpected result that
        a client wants. "dsihash" is used to mitigate this. The TEE MUST
        store DSI state and check that the DSI state matches before it
        does another update.
        </t>

        <t> Concurrent calls from a TAM to a TEE MUST be handled properly by a
        TEE. If multiple concurrent TAM operations take place, these could
        fail due to the "dsihash" being modified by another concurrent operation.
        The TEE is responsible for resolve any locking such that one
        application cannot lock other applications from using the TEE, except
        for a short term duration of the TAM operation taking place. For
        example, an OTrP operation that starts but never completes (e.g. loss
        of connectivity) must not prevent subsequent OTrP messages from being
        executed. </t>
      </section>

      <section title="Compromised CA">
        <t> A root CA for TAM certificates might get compromised. Some TEE
        trust anchor update mechanism is expected from device OEMs. A compromised
        intermediate CA is covered by OCSP stapling and OCSP validation check
        in the protocol. A TEE should validate certificate revocation about a
        TAM certificate chain. </t>

        <t> If the root CA of some TEE device certificates is compromised,
        these devices might be rejected by a TAM, which is a decision of the
        TAM implementation and policy choice. Any intermediate CA for TEE device
        certificates SHOULD be validated by TAM with a Certificate
        Revocation List (CRL) or Online Certificate Status Protocol (OCSP)
        method.
        </t>
      </section>

      <section title="Compromised TAM">
        <t> The TEE SHOULD use validation of the supplied TAM certificates and
        OCSP stapled data to validate that the TAM is trustworthy. </t>

        <t> Since PKI is used, the integrity of the clock within the TEE
        determines the ability of the TEE to reject an expired TAM certificate,
        or revoked TAM certificate. Since OCSP stapling includes signature
        generation time, certificate validity dates are compared to the current
        time.</t>
      </section>

      <section title="Certificate Renewal">
        <t> TFW and TEE device certificates are expected to be long lived,
          longer than the
        lifetime of a device. A TAM certificate usually has a moderate
        lifetime of 2 to 5 years. A TAM should get renewed or rekeyed
        certificates. The root CA certificates for a TAM, which are embedded
        into the trust anchor store in
        a device, should have long lifetimes that don't require device trust
        anchor update. On the other hand, it is imperative that OEMs or device
        providers plan for support of trust anchor update in their shipped
        devices. </t>
      </section>

    </section> <!-- Security Consideration -->

  

  </middle>

  <back>
    <references title="Normative References">
     &RFC2119;
     &RFC4648;
     &RFC7159;
     &RFC7515;
     &RFC7516;
     &RFC7517;
     &RFC7518;
    </references> <!-- Normative References --> 

    <references title="Informative References">

      &I-D.ietf-teep-architecture;      
  
      <reference anchor="GPTEE">
        <front>
          <title>Global Platform, GlobalPlatform Device Technology:
            TEE System Architecture, v1.0</title>
          <author>
            <organization>Global Platform</organization>
          </author>
          <date year="2013" />
        </front>
      </reference>
      <reference anchor="GPTEECLAPI">
        <front>
          <title>Global Platform, GlobalPlatform Device Technology:
            TEE Client API Specification, v1.0</title>
          <author>
            <organization>Global Platform</organization>
          </author>
          <date year="2013" />
        </front>
      </reference>
    </references> <!-- Informative References --> 

  <section anchor="Acknowledgements" title="Acknowledgements">
      <t>We thank Alin Mutu for his contribution to many discussion that helped
      to design the trust flow mechanisms, and the creation of the flow diagrams.
      We also thank the following people (in alphabetical order) for their input
      and review: Sangsu Baek, Rob Coombs, Dapeng Liu, and
      Pengfei Zhao.
      </t>
    </section> <!-- Acknowledgements --> 

   <section anchor="Contributors" title="Contributors">
    
    <t>We would like to thank the following individuals for their contributions to an earlier version
    of this specification.</t> 
    
        <figure>
          <artwork><![CDATA[
- Brian Witten
  Symantec
  brian_witten@symantec.com

- Tyler Kim
  Solacia
  tylerkim@iotrust.kr

- Nick Cook
  Arm Ltd.
  nicholas.cook@arm.com
  
- Minho Yoo  
  IoTrust
  minho.yoo@iotrust.kr
         ]]></artwork>
        </figure>
    </section> <!-- Contributors --> 
    
  </back>
</rfc>
