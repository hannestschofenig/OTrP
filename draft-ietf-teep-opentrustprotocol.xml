<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4648 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY RFC7159 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7159.xml">
<!ENTITY RFC7515 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7515.xml">
<!ENTITY RFC7516 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7516.xml">
<!ENTITY RFC7517 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7517.xml">
<!ENTITY RFC7518 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7518.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<!-- <?rfc compact="yes" ?> -->
<?rfc subcompact="no" ?>
<rfc category="std" docName="draft-ietf-teep-opentrustprotocol-04.txt" ipr="trust200902"
  submissionType="IETF">
  <front>
    <title abbrev="OTrP">The Open Trust Protocol (OTrP)</title>

    <author fullname="Mingliang Pei" initials="M." surname="Pei">
      <organization>Symantec</organization>
      <address>
        <postal>
          <street>350 Ellis St</street>
          <city>Mountain View</city>
          <region>CA</region>
          <code>94043</code>
          <country>USA</country>
        </postal>
        <email>mingliang_pei@symantec.com</email>
      </address>
    </author>

    <author fullname="Andrew Atyeo" initials="A." surname="Atyeo">
      <organization>Intercede</organization>
      <address>
        <postal>
          <street>St. Mary's Road, Lutterworth</street>
          <city>Leicestershire</city>
          <region>LE17</region>
          <code>4PS</code>
          <country>Great Britain</country>
        </postal>
        <email>andrew.atyeo@intercede.com</email>
      </address>
    </author>

    <author fullname="Hannes Tschofenig" initials="H." surname="Tschofenig">
      <organization>Arm Ltd.</organization>
      <address>
        <postal>
          <street>110 Fulbourn Rd</street>
          <city>Cambridge</city>
          <region>CB1</region>
          <code>9NJ</code>
          <country>Great Britain</country>
        </postal>
        <email>hannes.tschofenig@arm.com</email>
      </address>
    </author>

        <author fullname="David Wheeler" initials="D." surname="Wheeler">
      <organization>Intel</organization>
      <address>
        <postal>
          <street></street>
          <city></city>
          <region></region>
          <code></code>
          <country>US</country>
        </postal>
        <email>david.m.wheeler@intel.com</email>
      </address>
    </author>
       
    <author fullname="David Thaler" initials="D." surname="Thaler">
      <organization>Microsoft</organization>
      <address>
        <postal>
          <street></street>
          <city></city>
          <code></code>
          <country>US</country>
        </postal>
        <email>dthaler@microsoft.com</email>
      </address>
    </author>
    
    <date month="July" year="2019" />
    
    <area>Security</area>
    <workgroup>TEEP</workgroup>
    <keyword>Trusted Execution Environment</keyword>
    <abstract>
      <t>This document specifies the Open Trust Protocol (OTrP) version 2, a
      protocol that provisions and installs, updates, and deletes Trusted Applications 
      in a device with a Trusted Execution Environment (TEE).
      </t>
    </abstract>
  </front>

  <middle>
   <section anchor="introduction" title="Introduction">
      <t>The Trusted Execution Environment (TEE) concept has been designed to
      separate a regular operating system, also referred as a Rich Execution
      Environment (REE), from security-sensitive applications. In an TEE
      ecosystem, different device vendors may use different operating systems in the 
      REE and may use different types of TEEs. When application providers or 
      device administrators use Trusted Application Managers (TAMs) to install, update, 
      and delete Trusted Applications (TAs) on a wide range of devices with potentially 
      different TEEs then an interoperability need arises.</t>
      
      <t>This document specifies version 2 of the Open Trust Protocol (OTrP), a protocol 
      for communicating between an OTrP server (as part of a TAM)  and an OTrP client 
      (which is a client-side component running in the REE).
      </t>

      <t>The Trusted Execution Environment Provisioning (TEEP) architecture
      document <xref target="I-D.ietf-teep-architecture"/> has set to provide a design guidance
      for such an interoperable protocol.
      </t>

    </section>

    <section title="Requirements Language">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in
        <xref target="RFC2119"/>.
      </t>
      <t>This specification re-uses the terminology defined in 
      <xref target="I-D.ietf-teep-architecture" />.</t>
      
    </section>

    <section anchor="model" title="OTrP Entities and Trust Model">
      <section anchor="components" title="System Components">
        <t>The same system components as defined in the TEEP Architecture document
        <xref target="I-D.ietf-teep-architecture" /> are used in OTrP, including TAM, CA, TEE, REE,
        and OTrP Broker (a.k.a Broker).</t>

        <t>Secure boot (for the purposes of OTrP) is optional in enabling
          authenticity checking of TEEs by the TAM. A TAM provider can choose
          it policy whether it trusts a TEE if the underlying firmware attestation
          information is not included.
            </t>

        <t>OTrP uses trust anchors to establish trust between TEEs and TAMs and
          verifies that they communicate in a trusted way when performing
          lifecycle management transactions.
            </t>
      </section>

      <section anchor="teeanchors" title="Trust Anchors in TEE">
        <t>This assumes the Trust Anchor specification defined in the
        TEEP Architecture document <xref target="I-D.ietf-teep-architecture" />.
        </t>

        <t>Each TEE comes with a trust store that contains a
          whitelist of root CA certificates that are used to validate a TAM's
          certificate. A TEE will accept a TAM to create new Security Domains and
          install new TAs on behalf of a SP only if the TAM's certificate is
          chained to one of the root CA certificates in the TEE's trust
          store.
        </t>
      </section>

      <section anchor="TAManchors" title="Trust Anchors in TAM">
        <t>The Trust Anchor set in a TAM consists of a list of Certificate
          Authority certificates that signs various device TEE certificates.
          A TAM decides what TEE and optionally TFW it will trust when TFW
          signature data is present in an attestation.
        </t>
      </section>

      <section anchor="keytypes" title="Keys and Certificate Types">
        <t>OTrP leverages the following list of trust anchors and
          identities in generating signed and encrypted command messages that
          are exchanged between a device's TEE and a TAM. With these
          security artifacts, OTrP Messages are able to deliver end-to-end
          security without relying on any transport security.
        </t>

        <texttable anchor="keytypelist" title="Key and Certificate Types">
          <ttcol align='left'>Key Entity Name</ttcol>
          <ttcol align='left'>Location</ttcol>
          <ttcol align='left'>Issuer</ttcol>
          <ttcol align='left'>Trust Implication</ttcol>
          <ttcol align='left'>Cardinality</ttcol>

          <c>1. TFW key pair and certificate</c>
          <c>Device secure storage</c>
          <c>FW CA</c>
          <c>A whitelist of FW root CA trusted by TAMs</c>
          <c>1 per device</c>

          <c>2. TEE key pair and certificate</c>
          <c>Device TEE</c>
          <c>TEE CA under a root CA</c>
          <c>A whitelist of TEE root CA trusted by TAMs</c>
          <c>1 per device</c>

          <c>3. TAM key pair and certificate</c>
          <c>TAM provider</c>
          <c>TAM CA under a root CA</c>
          <c>A whitelist of TAM root CA embedded in TEE</c>
          <c>1 or multiple can be used by a TAM</c>

          <c>4. SP key pair and certificate</c>
          <c>SP</c>
          <c>SP signer CA</c>
          <c>TAM manages SP. TA trust is delegated to TAM. TEE trusts TAM to
            ensure that a TA is trustworthy.
          </c>
          <c>1 or multiple can be used by a TAM</c>

        </texttable>

        <t>
          <list hangIndent="4" style="hanging">
            <t hangText="1. TFW key pair and certificate:">
                A key pair and certificate for
                evidence of trustworthy firmware in a device. This key pair is
                optional. Some TEE may present its
                trusted attributes to a TAM using signed attestation with a
                TFW key. For example, a platform that uses a hardware based TEE
                can have attestation data signed by a hardware protected TFW key.
              <list hangIndent="2" style="hanging">
                <t hangText="Location: ">Device secure storage</t>
                <t hangText="Supported Key Type: ">RSA and ECC</t>
                <t hangText="Issuer: ">OEM CA</t>
                <t hangText="Trust Implication: ">A whitelist of FW root CA trusted
                  by TAMs
                </t>
                <t hangText="Cardinality: ">One per device</t>
              </list>
            </t>

            <t hangText="2. TEE key pair and certificate:">It is used for device
              attestation to a remote TAM and SP.
            </t>

            <t>This key pair is burned into the device at device manufacturer.
              The key pair and its certificate are valid for the expected
              lifetime of the device.
              <list hangIndent="2" style="hanging">
                <t hangText="Location: ">Device TEE</t>
                <t hangText="Supported Key Type: ">RSA and ECC</t>
                <t hangText="Issuer: ">A CA that chains to a TEE root CA</t>
                <t hangText="Trust Implication: ">A whitelist of TEE root CA
                  trusted by TAMs
                </t>
                <t hangText="Cardinality: ">One per device</t>
              </list>
            </t>

            <t hangText="3. TAM key pair and certificate:">A TAM provider acquires
              a certificate from a CA that a TEE trusts.
              <list hangIndent="2" style="hanging">
                <t hangText="Location: ">TAM provider</t>
                <t hangText="Supported Key Type: ">RSA and ECC.</t>
                <t hangText="Supported Key Size: ">RSA 2048-bit, ECC P-256
                  and P-384. Other sizes should be anticipated in future.
                </t>
                <t hangText="Issuer: ">TAM CA that chains to a root CA</t>
                <t hangText="Trust Implication: ">A whitelist of TAM root CA
                  embedded in TEE
                </t>
                <t hangText="Cardinality: ">One or multiple can be used by a TAM</t>
              </list>
            </t>

            <t hangText="4. SP key pair and certificate:">an SP uses its own key pair
              and certificate to sign a TA.
              <list hangIndent="2" style="hanging">
                <t hangText="Location: ">SP</t>
                <t hangText="Supported Key Type: ">RSA and ECC</t>
                <t hangText="Supported Key Size: ">RSA 2048-bit, ECC P-256
                  and P-384. Other sizes should be anticipated in future.
                </t>
                <t hangText="Issuer: ">an SP signer CA that chains to a root CA</t>
                <t hangText="Trust Implication: ">TAM manages SP. TA trusts an SP
                  by validating trust against a TAM that the SP uses. A TEE
                  trusts TAM to ensure that a TA from the TAM is trustworthy.
                </t>
                <t hangText="Cardinality: ">One or multiple can be used by an SP</t>
              </list>
            </t>
          </list>
        </t>
      </section>
    </section>

    <section anchor="overview" title="Protocol Scope and Entity Relations">
      <t>This document specifies messages and key properties that can
        establish mutual trust between a TEE and a TAM. The
        protocol provides specifications for the following three entities:
      </t>

      <t>
        <list style="numbers">
          <t>Key and certificate types required for device firmware, TEEs, TAs,
            SPs, and TAMs
          </t>
          <t>Data message formats that should be exchanged between a TEE in a
            device and a TAM
          </t>
          <t>An OTrP Broker in the REE that can relay
            messages between a Client Application and TEE
          </t>
        </list>
      </t>

      <t>Figure 1: Protocol Scope and Entity Relationship</t>

      <t>
       <figure>
       <preamble></preamble>
       <artwork align="left"><![CDATA[
PKI    CA    -- CA                                 CA --
        |    |                                         |
        |    |                                         |
        |    |                                         |
Device  |    |   --- OTrP Broker / Client App ---       |
SW      |    |   |                             |       |
        |    |   |                             |       |
        |    |   |                             |       |
OTrP    |    -- TEE                           TAM-------
        |
        |
       FW
          ]]></artwork>
       </figure>
      </t>

      <t>Figure 2: OTrP System Diagram</t>

      <t>
       <figure>
       <preamble></preamble>
       <artwork align="left"><![CDATA[

        -------OTrP Message Protocol---
        |                             |
        |                             |
 --------------------           ---------------   ----------
 |  REE   |  TEE    |           |    TAM      |   |  SP    |
 |  ---   |  ---    |           |    ---      |   |  --    |
 |        |         |           |             |   |        |
 | Client | SD (TAs)|           |   SD / TA   |   |  TA    |
 |  Apps  |         |           |     Mgmt    |   |        |
 |   |    |         |           |             |   |        |
 |   |    | List of |           |  List of    |   |        |
 | OTrP   | Trusted |           |  Trusted    |   |        |
 | Broker |  TAM/SP |           |   FW/TEE    |   |        |
 |        |   CAs   |           |    CAs      |   |        |
 |        |         |           |             |   |        |
 |        |TEE Key/ |           |  TAM Key/   |   | SP Key/|
 |        |  Cert   |           |    Cert     |   |  Cert |
 |        | FW Key/ |           |             |   |        |
 |        |  Cert   |           |             |   |        |
 --------------------           ---------------   ----------
              |                        |              |
              |                        |              |
        -------------              ----------      ---------
        | TEE CA    |              | TAM CA |      | SP CA |
        -------------              ----------      ---------
          ]]></artwork>
       </figure>
      </t>

      <t>In the previous diagram, different Certificate Authorities can be used
        respectively for different types of certificates. OTrP Messages are
        always signed, where the signer keys is the message creator's private
        key such as a FW's private key, a TEE's private key, or a TAM's
        private key.
      </t>

      <t>The main OTrP component consists of a set of standard JSON messages
        created by a TAM to deliver device SD and TA management commands to a
        device, and device attestation and response messages created by a TEE
        that responds to a TAM's OTrP message.
      </t>

      <t>The communication method of OTrP Messages between a TAM and TEE in a
      device may vary between TAM and TEE providers. A mandatory
      transport protocol is specified for a compliant TAM and a device TEE.
      </t>

      <t>An OTrP Broker is used to bridge communication between a TAM
      and a TEE. The OTrP Broker doesn't need to know the actual content of OTrP
      Messages except for the TEE routing information.
      </t>

      <section anchor="setupflow" title="A Sample Device Setup Flow">
          <t>Step 1: Prepare Images for Devices
            <list hangIndent="2" style="numbers">
              <t>[TEE vendor] Deliver TEE Image (CODE Binary) to device OEM</t>
              <t>[CA]         Deliver root CA Whitelist</t>
              <t>[Soc]        Deliver TFW Image</t>
            </list>
          </t>
          <t></t>

          <t>Step 2: Inject Key Pairs and Images to Devices
            <list hangIndent="2" style="numbers">
              <t>[OEM] Generate Secure Boot Key Pair
                       (May be shared among multiple devices)</t>
              <t>[OEM] Flash signed TFW Image and signed TEE Image
                       onto devices (signed by Secure Boot Key)</t>
            </list>
          </t>
          <t></t>

          <t>Step 3: Setup attestation key pairs in devices
            <list hangIndent="2" style="numbers">
              <t>[OEM]     Flash TFW Public Key and a bootloader key.</t>
              <t>[TFW/TEE] Generate a unique attestation key pair and
                           get a certificate for the device.</t>
            </list>
          </t>
          <t></t>

          <t>Step 4: Setup trust anchors in devices
            <list hangIndent="2" style="numbers">
              <t>[TFW/TEE] Store the key and certificate encrypted
                           with the eFuse key</t>
              <t>[TEE vendor or OEM] Store trusted CA certificate list
                           into devices</t>
            </list>
          </t>

      </section>

      <section anchor="derivedkeys" title="Derived Keys in The Protocol">
        <t>
          The protocol generates one key pair in run time to
          assist message communication and anonymous verification between
          a TAM and a TEE.
        </t>

        <t>
          TEE SP Anonymous Key (AIK): one derived key pair per SP in a device
        </t>
        <t>
          The purpose of the key pair is to sign data by a TEE without
          using its TEE device key for anonymous attestation to a Client
          Application. This key pair is generated in the first SD
          creation for an SP. It is deleted when all SDs are removed for a
          SP in a device.

          The public key of the key pair is given to the caller Client
          Application and TAM for future TEE returned data validation.
          The public key of this AIK is also used by a TAM to encrypt TA
          binary data and personalization data when it sends a TA to a
          device for installation.
        </t>
      </section>

      <section anchor="sdtree" title="Security Domain Hierarchy and Ownership">
        <t>
          The primary job of a TAM is to help an SP to manage its trusted
          application components. A TA is typically installed in an SD.
          An SD is commonly created for an SP.
        </t>
        <t>
          When an SP delegates its SD and TA management to a TAM, an SD is
          created on behalf of a TAM in a TEE and the owner of the SD is
          assigned to the TAM. An SD may be associated with an SP but the TAM
          has full privilege to manage the SD for the SP.
        </t>
        <t>
          Each SD for an SP is associated with only one TAM. When an SP changes
          TAM, a new SP SD must be created to associate with the new TAM. The
          TEE will maintain a registry of TAM ID and SP SD ID mapping.
        </t>
        <t>
          From an SD ownership perspective, the SD tree is flat and there is
          only one level. An SD is associated with its owner. It is up to TEE
          implementation how it maintains SD binding information for a TAM and
          different SPs under the same TAM.
        </t>
        <t>
          It is an important decision in this protocol specification that a TEE
          doesn't need to know whether a TAM is authorized to manage the SD for
          an SP. This authorization is implicitly triggered by an SP Client
          Application, which instructs what TAM it wants to use. An SD is always
          associated with a TAM in addition to its SP ID. A rogue TAM isn't
          able to do anything on an unauthorized SP's SD managed by another TAM.
        </t>
        <t>
          Since a TAM may support multiple SPs, sharing the same SD name for
          different SPs creates a dependency in deleting an SD. An SD can be
          deleted only after all TAs associated with this SD is deleted. An SP
          cannot delete a Security Domain on its own with a TAM if a TAM
          decides to introduce such sharing. There are cases where multiple
          virtual SPs belong to the same organization, and a TAM chooses to use
          the same SD name for those SPs. This is totally up to the TAM
          implementation and out of scope of this specification.
        </t>
      </section>

      <section anchor="sdownerid"
        title="SD Owner Identification and TAM Certificate Requirements">
        <t>
          There is a need of cryptographically binding proof about the owner of
          an SD in a device. When an SD is created on behalf of a TAM, a future
          request from the TAM must present itself as a way that the TEE can
          verify it is the true owner. The certificate itself cannot reliably
          used as the owner because TAM may change its certificate.
        </t>
        <t>
          To this end, each TAM will be associated with a trusted identifier
          defined as an attribute in the TAM certificate. This field is kept
          the same when the TAM renew its certificates. A TAM CA is responsible
          to vet the requested TAM attribute value.
        </t>
        <t>
          This identifier value must not collide among different TAM providers,
          and one TAM shouldn't be able to claim the identifier used by another
          TAM provider.
        </t>
        <t>
          The certificate extension name to carry the identifier can initially
          use SubjectAltName:registeredID. A dedicated new extension name may
          be registered later.
        </t>
        <t>
          One common choice of the identifier value is the TAM's service URL. A
          CA can verify the domain ownership of the URL with the TAM in the
          certificate enrollment process.
        </t>
        <t>
          A TEE can assign this certificate attribute value as the TAM owner ID
          for the SDs that are created for the TAM.
        </t>
        <t>
          An alternative way to represent an SD ownership by a TAM is to have a
          unique secret key upon SD creation such that only the creator TAM is
          able to produce a Proof-of-Possession (POP) data with the secret.
        </t>
      </section>

      <section anchor="spcontainer" title="Service Provider Container">
        <t>A sample Security Domain hierarchy for the TEE is shown below.
        </t>

        <t>
            <figure>
              <artwork><![CDATA[
    ----------
    |  TEE   |
    ----------
        |
        |          ----------
        |----------| SP1 SD1 |
        |          ----------
        |          ----------
        |----------| SP1 SD2 |
        |          ----------
        |          ----------
        |----------| SP2 SD1 |
                   ----------
             ]]></artwork>
            </figure>
        </t>
        <t>OTrP segregates SDs and TAs such that a TAM can only manage or
          retrieve data for SDs and TAs that it previously created for the
          SPs it represents.
        </t>
      </section>
    </section>


    <section anchor="messages" title="OTrP Messages">
      <t>The main OTrP component is the set of standard JSON messages
        created by a TAM to deliver device SD and TA management commands to a
        device, and device attestation and response messages created by TEE to
        respond to TAM OTrP Messages.
      </t>
      <t>
        An OTrP Message is designed to provide end-to-end security. It is always
        signed by its creator. In addition, an OTrP Message is typically
        encrypted such that only the targeted device TEE or TAM is able
        to decrypt and view the actual content.
      </t>
      <section anchor="format" title="Message Format">
        <t>OTrP Messages use the JSON format for JSON's simple readability and
          moderate data size in comparison with alternative TLV and XML
          formats. More compact CBOR format may be used as an alternative
          choice.
        </t>
        <t>
          JSON Message security has developed JSON Web Signing and JSON Web
          Encryption
          standard in the IETF Workgroup JOSE, see JWS <xref target="RFC7515"/>
          and JWE <xref target="RFC7516"/>.
          The OTrP Messages in this protocol will leverage the basic JWS and JWE
          to handle JSON signing and encryption.
        </t>
      </section>

      <section anchor="convention" title="Message Naming Convention">
        <t>For each TAM command "xyz"", OTrP use the following naming
          convention to represent its raw message content and complete request
          and response messages:
        </t>
        <texttable>
          <ttcol align="left">Purpose</ttcol>
          <ttcol align="left">Message Name</ttcol>
          <ttcol align="left">Example</ttcol>

          <c>Request to be signed</c>
          <c>xyzTBSRequest</c>
          <c>CreateSDTBSRequest</c>

          <c>Request message</c>
          <c>xyzRequest</c>
          <c>CreateSDRequest</c>

          <c>Response to be signed</c>
          <c>xyzTBSResponse</c>
          <c>CreateSDTBSResponse</c>

          <c>Response message</c>
          <c>xyzResponse</c>
          <c>CreateSDResponse</c>
        </texttable>

      </section>

      <section anchor="template" title="Request and Response Message Template">
        <figure>
          <preamble>An OTrP Request message uses the following format:
          </preamble>

          <artwork><![CDATA[
  {
    "<name>TBSRequest": {
      <request message content>
    }
  }
           ]]></artwork>
        </figure>

        <figure>
          <preamble>A corresponding OTrP Response message will be as follows.
          </preamble>

          <artwork><![CDATA[
  {
    "<name>TBSResponse": {
      <response message content>
    }
  }
           ]]></artwork>
        </figure>

      </section>

      <section anchor="signedmsg" title="Signed Request and Response Message Structure">
        <t>
          A signed request message will generally include only one signature,
          and uses the flattened JWS JSON Serialization Syntax, see Section
          7.2.2 in <xref target="RFC7515"/>.
        </t>
        <figure>
          <preamble>A general JWS object looks like the following.
          </preamble>

          <artwork><![CDATA[
{
  "payload": "<payload contents>",
  "protected": "<integrity-protected header contents>",
  "header": {
    <non-integrity-protected header contents>,
  },
  "signature": "<signature contents>"
}
           ]]></artwork>
        </figure>

        <t>OTrP signed messages only require the signing algorithm as the
          mandate header in the property "protected". The
          "non-integrity-protected header contents" is optional.
        </t>
        <t>
          OTrP signed message will be given an explicit Request or Response
          property
          name. In other words, a signed Request or Response uses the
          following
          template.
        </t>
        <figure>
          <preamble>A general JWS object looks like the following.
          </preamble>

          <artwork><![CDATA[
{
  "<name>[Request | Response]": {
    <JWS Message of <name>TBS[Request | Response]
  }
}
           ]]></artwork>
        </figure>

        <t>With the standard JWS message format, a signed OTrP Message looks
          like the following.
        </t>
        <figure>
          <artwork><![CDATA[
{
  "<name>[Request | Response]": {
    "payload": "<payload contents of <name>TBS[Request | Response]>",
    "protected": "<integrity-protected header contents>",
    "header":  <non-integrity-protected header contents>,
    "signature": "<signature contents>"
  }
}
           ]]></artwork>
        </figure>

        <t>
          The top element "&lt;name&gt;[Signed][Request|Response]" cannot be
          fully trusted to match the content because it doesn't participate
          in the signature generation. However, a recipient can always match
          it with the value associated with the property "payload". It
          purely serves to provide a quick reference for reading and
          method invocation.
        </t>
        <t>Furthermore, most properties in an unsigned OTrP messages are
          encrypted to provide end-to-end confidentiality. The only OTrP message
          that isn't encrypted is the initial device query message that asks
          for the device state information.
        </t>
        <t>Thus a typical OTrP Message consists of an encrypted and then signed
          JSON message. Some transaction data such as transaction ID and TEE
          information may need to be exposed to the OTrP Broker for routing
          purpose. Such information is excluded from JSON encryption.
          The device's signer certificate itself is encrypted. The overall
          final message is a standard signed JSON message.
        </t>
        <t>As required by JSW/JWE, those JWE and JWS related elements will be
          BASE64URL encoded. Other binary data elements specific to the OTrP
          specification are BASE64-encoded. This specification indicates
          elements that should be BASE64 and those elements that are to be
          BASE64URL encoded.
        </t>

        <section
          title="Identifying Signing and Encryption Keys for JWS/JWE Messaging">
          <t>
            JWS and JWE messaging allow various options for identifying the
            signing and encryption keys, for example, it allows optional
            elements including "x5c", "x5t" and "kid" in the header to cover
            various possibilities.
          </t>
          <t>
            To protect privacy, it is important that the device's
            certificate is released only to a trusted TAM, and that it is
            encrypted. The TAM will need to know the device certificate, but
            untrusted parties must not be able to get the device certificate.
            All OTrP messaging conversations between a TAM and device begin
            with GetDeviceStateRequest / GetDeviceStateResponse. These messages
            have elements built into them to exchange signing certificates,
            described in the section <xref target="detailmsg"/>. Any
            subsequent messages in the conversation that follow on from this
            implicitly use the same certificates for signing/encryption,
            and as a result the certificates or references
            may be omitted in those subsequent messages.
          </t>
          <t>
            In other words, the signing key identifier in the use of JWS and
            JWE here may be absent in the subsequent messages after the
            initial GetDeviceState query.
          </t>
          <t>
            This has an implication on the TEE and TAM implementation: they
            have to cache the signer certificates for the subsequent
            message signature validation in the session. It may be easier
            for a TAM service to cache transaction session information
            but not so for a TEE in a device. A TAM can get a
            device's capability by checking the response message from a TEE
            to decide whether it should include its TAM signer certificate
            and OCSP data in each subsequent request message. The device's
            caching capability is reported
            in GetDeviceStateResponse signerreq parameter.
          </t>
        </section>
      </section>

      <section title="JSON Signing and Encryption Algorithms">
        <t>
          The OTrP JSON signing algorithm shall use SHA256 or a stronger
          hash method with respective key type. JSON Web Algorithm RS256
          or ES256 <xref target="RFC7518"/> SHALL be used for RSA with SHA256 and
          ECDSA with SHA256. If RSA with SHA256 is used, the JSON web
          algorithm representation is as follows.
        </t>

        <t>
          <list hangIndent="4" style="empty">
            <t>{"alg":"RS256"}</t>
          </list>
        </t>

        <t>
          The (BASE64URL encoded) "protected" header property in a signed
          message looks like the following:
          <list hangIndent="4" style="empty">
            <t>"protected":"eyJhbGciOiJSUzI1NiJ9"</t>
          </list>
        </t>

        <t>
          If ECSDA with P-256 curve and SHA256 are used for signing, the JSON
          signing algorithm representation is as follows.

          <list hangIndent="4" style="empty">
            <t>{"alg":"ES256"}</t>
          </list>
        </t>

        <t>
          The value for the "protected" field will be the following.
          <list hangIndent="4" style="empty">
            <t>eyJhbGciOiJFUzI1NiJ9</t>
          </list>
        </t>

        <figure>
          <preamble>Thus, a common OTrP signed message with ES256 looks like the
            following.
          </preamble>
          <artwork><![CDATA[
  {
    "payload": "<payload contents>",
    "protected": "eyJhbGciOiJFUzI1NiJ9",
    "signature": "<signature contents>"
  }
           ]]></artwork>
        </figure>

        <t>The OTrP JSON message encryption algorithm SHOULD use one of the
          supported algorithms defined in the later chapter of this document.
          JSON encryption uses a symmetric key as its "Content Encryption Key
          (CEK)". This CEK is encrypted or wrapped by a recipient's key.
          The OTrP recipient typically has an asymmetric key pair. Therefore,
          the CEK will be encrypted by the recipient's public key.
        </t>

        <t>
          A compliant implementation shall support the following symmetric
          encryption algorithm and anticipate future new algorithms.
          <list hangIndent="4" style="empty">
            <t>{"enc":"A128CBC-HS256"}</t>
          </list>
        </t>

        <t>
          This algorithm represents encryption with AES 128 in CBC mode with
          HMAC SHA 256 for integrity. The value of the property "protected" in
          a JWE message will be
          <list hangIndent="4" style="empty">
            <t>eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0</t>
          </list>
        </t>

        <figure>
          <preamble>An encrypted JSON message looks like the following.
          </preamble>

          <artwork><![CDATA[
  {
    "protected": "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0",
     "recipients": [
        {
            "header": {
                "alg": "<RSA1_5 etc.>"
            },
            "encrypted_key": "<encrypted value of CEK>"
        }
    ],
    "iv": "<BASE64URL encoded IV data>",
    "ciphertext": "<Encrypted data over the JSON plaintext
                   (BASE64URL)>",
    "tag": "<JWE authentication tag (BASE64URL)>"
  }
           ]]></artwork>
        </figure>

        <t>OTrP doesn't use JWE AAD (Additional Authenticated Data) because
          each message is always signed after the message is encrypted.
        </t>

        <section anchor="signalgs" title="Supported JSON Signing Algorithms">
          <t>
            The following JSON signature algorithm is mandatory support in
            the TEE and TAM:
            <list hangIndent="4" style="symbols">
              <t>RS256</t>
            </list>
          </t>
          <t>ES256 is optional to support.
          </t>
        </section>

        <section anchor="encalgs" title="Support JSON Encryption Algorithms">
          <t>
            The following JSON authenticated encryption algorithm is mandatory
            support in TEE and TAM.
            <list hangIndent="4" style="symbols">
              <t>A128CBC-HS256</t>

            </list>
          </t>
              <t>A256CBC-HS512 is optional to support.</t>
        </section>

        <section anchor="kmalgs" title="Supported JSON Key Management Algorithms">
          <t>
            The following JSON key management algorithm is mandatory
            support in TEE and TAM.
            <list hangIndent="4" style="symbols">
              <t>RSA1_5</t>
            </list>
          </t>

          <t>ECDH-ES+A128KW and ECDH-ES+A256KW are optional to support.</t>
        </section>

      </section>

      <section anchor="commerr" title="Common Errors">
        <t>
          An OTrP Response message typically needs to report the operation
          status and error causes if an operation fails. The following JSON
          message elements should be used across all OTrP Messages.
        </t>

        <figure>
          <artwork><![CDATA[
"status": "pass | fail"

 "reason": {
     "error-code": "<error code if there is any>",
     "error-message": "<error message>"
  }

"ver": "<version string>"
           ]]></artwork>
        </figure>

      </section>

      <section title="OTrP Message List">
        <t>
          The following table lists the OTrP commands and therefore
          corresponding Request and Response messages defined in this
          specification. Additional messages may be added in the future
          when new task messages are needed.
        </t>
        <t>
          <list hangIndent="4" style="hanging">
            <t hangText="GetDeviceState - ">
              <vspace blankLines="0" />
              A TAM queries a device's current state with a message
              GetDeviceStateRequest. A device TEE will report its
              version, its FW version, and list of all SDs and TAs in the
              device that is managed by the requesting TAM. TAM may
              determine whether the device is trustworthy and decide to
              carry out additional commands according to the response
              from this query.
            </t>
            <t hangText="CreateSD - ">
              <vspace blankLines="0" />
              A TAM instructs a device TEE to create an SD for an SP. The
              recipient TEE will check whether the requesting TAM is
              trustworthy.
            </t>
            <t hangText="UpdateSD - ">
              <vspace blankLines="0" />
              A TAM instructs a device TEE to update an existing SD. A
              typical update need comes from SP certificate change, TAM
              certificate change and so on. The recipient TEE will verify
              whether the TAM is trustworthy and owns the SD.
            </t>
            <t hangText="DeleteSD - ">
              <vspace blankLines="0" />
              A TAM instructs a device TEE to delete an existing SD. A
              TEE conditionally deletes TAs loaded in the SD according to
              a request parameter. An SD cannot be deleted until all TAs
              in this SD are deleted. If this is the last SD for an SP,
              TEE MAY also delete TEE SP AIK key for this SP.
            </t>
            <t hangText="InstallTA - ">
              <vspace blankLines="0" />
              A TAM instructs a device to install a TA into an SD for a
              SP. The TEE in a device will check whether the TAM and TA are
              trustworthy.
            </t>
            <t hangText="UpdateTA - ">
              <vspace blankLines="0" />
              A TAM instructs a device to update a TA into an SD for an SP.
              The change may commonly be bug fix for a previously
              installed TA.
            </t>
            <t hangText="DeleteTA - ">
              <vspace blankLines="0" />
              A TAM instructs a device to delete a TA. The TEE in a device
              will check whether the TAM and TA are trustworthy.
            </t>
          </list>
        </t>
      </section>

      <section title="OTrP Request Message Routing Rules">
        <t>
          For each command that a TAM wants to send to a device, the TAM
          generates a request message. This is typically triggered by a
          Client Application that uses the TAM. The Client Application
          initiates contact with the TAM and receives TAM OTrP Request
          messages according to the TAM's implementation. The Client
          Application forwards the OTrP message to an OTrP Broker in the
          device, which in turn sends the message to the active TEE in
          the device.
        </t>
        <t>The current version of this specification assumes that each device has
          only one active TEE, and the OTrP Broker is responsible to connect to
          the active TEE. This is the case today with devices in the market.
        </t>
        <t>When the TEE responds to a request, the OTrP Broker gets the OTrP
          response messages back to the Client Application that sent the
          request. In case the target TEE fails to respond to the request, the
          OTrP Broker will be responsible to generate an error message to reply
          the Client Application. The Client Application forwards any data it
          received to its TAM.
        </t>

        <section title="SP Anonymous Attestation Key (SP AIK)">
          <t>When the first new Security Domain is created in a TEE for an SP,
            a new key pair is generated and associated with this SP. This
            key pair is used for future device attestation to the service
            provider instead of using the device's TEE key pair.
          </t>
        </section>
      </section>
    </section>

    <section anchor="transport" title="Transport Protocol Support">
      <t>The OTrP message exchange between a TEE device and TAM generally
        takes place between a Client Application in REE and TAM. A device that
        is capable to run a TEE and PKI based cryptographic attestation isn't
        generally resource constraint to carry out standard HTTPS connections.
        A compliant device and TAM SHOULD support HTTPs.
      </t>
    </section>

    <section anchor="detailmsg" title="Detailed Messages Specification">
      <t>For each message in the following sections all JSON elements are
        mandatory if not explicitly indicated as optional.
      </t>
      <section anchor="getdevicestate" title="GetDeviceState">
        <t>
          This is the first command that a TAM will send to a device. This
          command is triggered when an SP's Client Application contacts
          its TAM to check whether the underlying device is ready for TA
          operations.
        </t>
        <t>
          This command queries a device's current TEE state. A device TEE
          will report its version, its FW version, and list of all SDs and
          TAs in the device that is managed by the requesting TAM. TAM may
          determine whether the device is trustworthy and decide to carry
          out additional commands according to the response from this
          query.
        </t>
        <t>
          The request message of this command is signed by the TAM. The
          response message from the TEE is encrypted. A random message
          encryption key (MK) is generated by TEE, and this encrypted key
          is encrypted by the TAM's public key such that only the TAM that
          sent the request is able to decrypt and view the response
          message.
        </t>

        <section anchor="getdsreq" title="GetDeviceStateRequest message">

          <figure>
            <artwork><![CDATA[
{
   "GetDeviceStateTBSRequest": {
      "ver": "1.0",
      "rid": "<Unique request ID>",
      "tid": "<transaction ID>",
      "ocspdat": [<a list of OCSP stapling data>"],
      "supportedsigalgs": [<array of supported signing algorithms>]
    }
}
           ]]></artwork>
          </figure>

          <t>
            The request message consists of the following data elements:
            <list hangIndent="4" style="hanging">
              <t hangText="ver - ">version of the message format</t>
              <t hangText="rid - ">a unique request ID generated by the TAM</t>
              <t hangText="tid - ">a unique transaction ID to trace request and
                response. This can be from a prior transaction's tid field, and
                can be used in  subsequent message exchanges in this TAM
                session. The combination of rid and tid MUST be made unique.
              </t>
              <t hangText="ocspdat - ">A list of OCSP stapling data respectively
                for the TAM certificate and each of the CA certificates up to
                the root certificate. The TAM provides OCSP data such that a
                recipient TEE can validate the TAM certificate chain revocation
                status without making its own external OCSP service call. A TEE
                MAY cache the CA OCSP data such that the array may contain only
                the OCSP stapling data for the TAM certificate in subsequent
                exchanges. This is a mandatory field.
              </t>
              <t hangText="supportedsigalgs - ">an optional property to list
                the signing algorithms that the TAM is able to support. A
                recipient TEE MUST choose an algorithm in this list to sign
                its response message if this property is present in a request.
                If it is absent, the TEE may use any compliant signing algorithm
                that is listed as mandatory support in this specification.
              </t>
            </list>
          </t>

          <figure>
            <preamble>The final request message is JSON signed message
            of the above raw JSON data with TAM's certificate.
            </preamble>

            <artwork><![CDATA[
{
  "GetDeviceStateRequest": {
    "payload": "<BASE64URL encoding of the GetDeviceStateTBSRequest
               JSON above>",
    "protected": "<BASE64URL encoded signing algorithm>",
    "header": {
        "x5c": "<BASE64 encoded TAM certificate chain up to the
                root CA certificate>"
    },
    "signature":"<signature contents signed by TAM private key>"
  }
}
          ]]></artwork>
          </figure>

          <t>The signing algorithm SHOULD use SHA256 with respective key
            type. The mandatory algorithm support is the RSA signing
            algorithm. The signer header "x5c" is used to include the TAM
            signer certificate up to the root CA certificate.
          </t>

        </section>

        <section title="Request processing requirements at a TEE">
          <t> Upon receiving a request message GetDeviceStateRequest at a
          TEE, the TEE MUST validate a request:

            <list hangIndent="2" style="numbers">
              <t>Validate JSON message signing. If it doesn't pass, an error
              message is returned.</t>
              <t>Validate that the request TAM certificate is chained to a
              trusted CA that the TEE embeds as its trust anchor.
                <list hangIndent="2" style="symbols">
                  <t>Cache the CA OCSP stapling data and certificate
                  revocation check status for other subsequent requests.
                  </t>
                  <t>A TEE can use its own clock time for the OCSP stapling
                  data validation. </t>
                </list></t>
              <t>Optionally collect Firmware signed data
                <list hangIndent="2" style="symbols">
                  <t>This is a capability in ARM architecture that allows a
                  TEE to query Firmware to get FW signed data. It isn't required
                  for all TEE implementations. When TFW signed data is absent,
                  it is up to a TAM's policy how it will trust a TEE.</t>
                </list></t>
              <t>Collect SD information for the SD owned by this TAM</t>
            </list>
          </t>
        </section>

        <section title="Firmware Signed Data">
          <t> Firmware isn't expected to process or produce JSON data. It
          is expected to just sign some raw bytes of data.</t>

          <t>The data to be signed by TFW key needs be some unique random
          data each time. The (UTF-8 encoded) "tid" value from the
          GetDeviceStateTBSRequest shall be signed by the firmware. TAM
          isn't expected to parse TFW data except the signature
          validation and signer trust path validation.
          </t>

          <t>It is possible that a TEE can get some valid TFW signed data
          from another device. The TEE is responsible to validate TFW integrity
          to ensure that the underlying device firmware is trustworthy. In
          some cases, a TEE isn't able to get a TFW signed data, in which
          case the TEE trust validation is up to a TAM to decide. A TAM
          may opt to trust a TEE basing on the TEE signer and additional
          information about a TEE out-of-band.
          </t>

          <t>When TFW signed data is available, a TAM validates the TEE and
            trusts that a trusted TEE has carried out appropriate trust check
            about a TFW.
          </t>

          <figure>
            <artwork><![CDATA[
  TfwData: {
       "tbs": "<TFW to be signed data, BASE64 encoded>",
       "cert": "<BASE64 encoded TFW certificate>",
       "sigalg": "Signing method",
       "sig": "<TFW signed data,  BASE64 encoded>"
  }
           ]]></artwork>
          </figure>

          <t>It is expected that a FW uses standard signature methods for
          maximal interoperability with TAM providers. The mandatory
          support list of signing algorithm is RSA with SHA256.
          </t>

          <t>The JSON object above is constructed by a TEE with data
          returned from the FW. It isn't a standard JSON signed object. The
          signer information and data to be signed must be specially
          processed by a TAM according to the definition given here. The data
          to be signed is the raw data.
          </t>

          <section title="Supported Firmware Signature Methods">
            <t>TAM providers shall support the following signature
            methods. A firmware provider can choose one of the methods in
            signature generation.
              <list hangIndent="2" style="symbols">
                <t>RSA with SHA256</t>
                <t>ECDSA with SHA 256</t>
              </list></t>

            <t>The value of "sigalg" in the TfwData JSON message SHOULD use
               one of the following:
              <list hangIndent="2" style="symbols">
                <t>RS256</t>
                <t>ES256</t>
              </list>
            </t>
          </section>
        </section>

        <section title="Post Conditions">
          <t>Upon successful request validation, the TEE information is
          collected. There is no change in the TEE in the device.
          </t>

          <t>The response message shall be encrypted where the encryption
          key shall be a symmetric key that is wrapped by TAM's public
          key. The JSON Content Encryption Key (CEK) is used for this
          purpose.
          </t>
        </section>

        <section anchor="getdsresp" title="GetDeviceStateResponse Message">
          <t>The message has the following structure.</t>
          <figure>
            <artwork><![CDATA[
  {
    "GetDeviceTEEStateTBSResponse": {
        "ver": "1.0",
        "status": "pass | fail",
        "rid": "<the request ID from the request message>",
        "tid": "<the transaction ID from the request message>",
        "signerreq": true | false // about whether TAM needs to send
                      signer data again in subsequent messages,
        "edsi": "<Encrypted JSON DSI information>"
    }
 }
           ]]></artwork>
          </figure>

          <t>
            where
            <list hangIndent="4" style="hanging">
              <t hangText="signerreq - ">true if the TAM should send its
              signer certificate and OCSP data again in the subsequent
              messages. The value may be "false" if the TEE caches the
              TAM's signer certificate and OCSP status.</t>
              <t hangText="rid - ">the request ID from the request message</t>
              <t hangText="tid - ">the tid from the request message</t>
              <t hangText="edsi - ">the main data element whose value is
              JSON encrypted message over the following Device State
              Information (DSI).</t>
            </list>
          </t>


          <t>The Device State Information (DSI) message consists of the
          following.</t>
<t>
          <figure>
            <artwork><![CDATA[
{
    "dsi": {
        "tfwdata": {
            "tbs": "<TFW to be signed data is the tid>"
            "cert": "<BASE64 encoded TFW certificate>",
            "sigalg": "Signing method",
            "sig": "<TFW signed data, BASE64 encoded>"
        },
        "tee": {
            "name": "<TEE name>",
            "ver": "<TEE version>",
            "cert": "<BASE64 encoded TEE cert>",
            "cacert": "<JSON array value of CA certificates up to
                        the root CA>",
            "sdlist": {
                "cnt": "<Number of SD owned by this TAM>",
                "sd": [
                    {
                        "name": "<SD name>",
                        "spid": "<SP owner ID of this SD>",
                        "talist": [
                          {
                             "taid": "<TA application identifier>",
                             "taname": "<TA application friendly
                                       name>" // optional
                          }
                        ]
                    }
                ]
            },
            "teeaiklist": [
                {
                    "spaik": "<SP AIK public key, BASE64 encoded>",
                    "spaiktype": "<RSA | ECC>",
                    "spid": "<sp id>"
                }
            ]
        }
    }
}
           ]]></artwork>
          </figure>
</t>

          <t>The encrypted JSON message looks like the following.</t>

          <figure>
            <artwork><![CDATA[
{
    "protected": "<BASE64URL encoding of encryption algorithm header
                   JSON data>",
    "recipients": [
        {
            "header": {
                "alg": "RSA1_5"
            },
            "encrypted_key": "<encrypted value of CEK>"
        }
    ],
    "iv": "<BASE64URL encoded IV data>",
    "ciphertext": "<Encrypted data over the JSON object of dsi
                    (BASE64URL)>",
    "tag": "<JWE authentication tag (BASE64URL)>"
}
           ]]></artwork>
          </figure>

          <t>Assume we encrypt plaintext with AES 128 in CBC mode with
          HMAC SHA 256 for integrity, the encryption algorithm header is:
            <list hangIndent="4" style="empty">
              <t>{"enc":"A128CBC-HS256"}</t>
            </list>
          </t>

          <t>The value of the property "protected" in the above JWE
          message will be
            <list hangIndent="4" style="empty">
              <t>eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0</t>
            </list>
          </t>

          <t>In other words, the above message looks like the following:</t>
          <figure>
            <artwork><![CDATA[
{
    "protected": "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0",
     "recipients": [
        {
            "header": {
                "alg": "RSA1_5"
            },
            "encrypted_key": "<encrypted value of CEK>"
        }
    ],
    "iv": "<BASE64URL encoded IV data>",
    "ciphertext": "<Encrypted data over the JSON object of dsi
                    (BASE64URL)>",
    "tag": "<JWE authentication tag (BASE64URL)>"
}
           ]]></artwork>
          </figure>

          <t>The full response message looks like the following:</t>
          <figure>
            <artwork><![CDATA[
{
  "GetDeviceTEEStateTBSResponse": {
    "ver": "1.0",
    "status": "pass | fail",
    "rid": "<the request ID from the request message>",
    "tid": "<the transaction ID from the request message>",
    "signerreq": "true | false",
    "edsi": {
      "protected": "<BASE64URL encoding of encryption algorithm
                     header JSON data>",
      "recipients": [
        {
          "header": {
            "alg": "RSA1_5"
          },
          "encrypted_key": "<encrypted value of CEK>"
        }
      ],
      "iv": "<BASE64URL encoded IV data>",
      "ciphertext": "<Encrypted data over the JSON object of dsi
                      (BASE64URL)>",
      "tag": "<JWE authentication tag (BASE64URL)>"
    }
  }
}
           ]]></artwork>
          </figure>

          <t>The CEK will be encrypted by the TAM public key in the
          device. The TEE signed message has the following structure.</t>
          <figure>
            <artwork><![CDATA[
{
  "GetDeviceTEEStateResponse": {
    "payload": "<BASE64URL encoding of the JSON message
                 GetDeviceTEEStateTBSResponse>",
    "protected": "<BASE64URL encoding of signing algorithm>",
    "signature": "<BASE64URL encoding of the signature value>"
  }
}
           ]]></artwork>
          </figure>

          <t>The signing algorithm shall use SHA256 with respective key
          type, see <xref target="signalgs"></xref>.
          </t>
          <t>The final GetDeviceStateResponse response message consists
          of an array of TEE responses.
          </t>

          <figure>
            <artwork><![CDATA[
{
    "GetDeviceStateResponse": [ // JSON array
       {"GetDeviceTEEStateResponse": ...},
       ...
       {"GetDeviceTEEStateResponse": ...}
    ]
}
           ]]></artwork>
          </figure>
        </section>

        <section title="Error Conditions">
          <t>An error may occur if a request isn't valid or the TEE runs
            into some error. The list of possible error conditions is the
            following.
            <list hangIndent="2" style="hanging">
            <t hangText="ERR_REQUEST_INVALID">The TEE meets the following
            conditions with a request message: (1) The request from a TAM
            has an invalid message structure; mandatory information is
            absent in the message; or an undefined member or structure is
            included.  (2) TEE fails to verify the signature of the message
            or fails to decrypt its contents.</t>
            <t hangText="ERR_UNSUPPORTED_MSG_VERSION">The TEE receives a
            version of message that the TEE can't deal with.</t>
            <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG">The TEE receives a
            request message encoded with a cryptographic algorithm that
            the TEE doesn't support.</t>
            <t hangText="ERR_TFW_NOT_TRUSTED">The TEE considers the
            underlying device firmware be not trustworthy.</t>
            <t hangText="ERR_TAM_NOT_TRUSTED">The TEE needs to make sure
            whether the TAM is trustworthy by checking the validity of
            the TAM certificate and OCSP stapling data and so on. If the TEE
            finds the TAM is not reliable, it returns this error code.</t>
            <t hangText="ERR_TEE_FAIL">If the TEE fails to
            process a request because of its internal error but is able
            to sign an error response message, it will return this error
            code.</t>
          </list></t>

          <t>The response message will look like the following if the TEE
          signing can work to sign the error response message.
          </t>
          <figure>
            <artwork><![CDATA[
  {
      "GetDeviceTEEStateTBSResponse": {
          "ver": "1.0",
          "status": "fail",
          "rid": "<the request ID from the request message>",
          "tid": "<the transaction ID from the request message>",
          "reason": {"error-code":"<error code>"}
          "supportedsigalgs": [<an array of signature algorithms that
                               the TEE supports>]
      }
  }
           ]]></artwork>
          </figure>

          <t>where
            <list hangIndent="4" style="hanging">
              <t hangText="supportedsigalgs -">an optional property to
              list the JWS signing algorithms that the active TEE
              supports. When a TAM sends a signed message that the TEE isn't
              able to validate, it can include signature algorithms that
              it is able to consume in this status report. A TAM can
              generate a new request message to retry the management task
              with a TEE-supported signing algorithm.</t>
            </list></t>

          <t>If the TEE isn't able to sign an error message due to an internal
            device error, a general error message should be returned by
            the OTrP Broker.
          </t>
        </section>

        <section title="TAM Processing Requirements">
          <t>Upon receiving a GetDeviceStateResponse message
          at a TAM, the TAM MUST validate the following.
            <list hangIndent="2" style="symbols">
              <t>Parse to get list of GetDeviceTEEStateResponse JSON
              objects</t>
              <t>Parse the JSON "payload" property and decrypt the JSON
              element "edsi". The decrypted message contains the TEE signer
              certificate.</t>
              <t>Validate the GetDeviceTEEStateResponse JSON signature. The
              signer certificate is extracted from the decrypted message
              in the last step.</t>
              <t>Extract TEE information and check it against its TEE
              acceptance policy.</t>
              <t>Extract the TFW signed element, and check the signer and
              data integration against its TFW policy.</t>
              <t>Check the SD list and TA list and prepare for a
              subsequent command such as "CreateSD" if it needs to have a
              new SD for an SP.</t>
            </list>
          </t>
        </section>

      </section> <!-- Get Device State -->

      <section anchor="tamgmt" title="Trusted Application Management">
        <t>This protocol doesn't introduce a TA container concept. All
        TA authorization and management will be up to the TEE
        implementation.
        </t>

        <t>The following three TA management commands are supported.
            <list hangIndent="2" style="symbols">
              <t>InstallTA - provision a TA by TAM</t>
              <t>UpdateTA - update a TA by TAM</t>
              <t>DeleteTA - remove TA registration information with an SD,
              remove the TA binary and all TA-related data in
              a TEE</t>
            </list>
        </t>

        <section anchor="installta" title="InstallTA">
          <t>TA binary data and related personalization data if there is any
            can be from two sources:
            <list hangIndent="2" style="numbers">
              <t>A TAM supplies the signed and encrypted TA binary</t>
              <t>A Client Application supplies the TA binary</t>
            </list>
          </t>

          <t>This specification primarily considers the first case where a TAM
          supplies a TA binary. This is to ensure that a TEE can properly
          validate whether a TA is trustworthy. Further, TA personalization data
          will be encrypted by the TEE device's SP public key for end-to-end
          protection. A Client Application bundled TA case will be addressed
          separately later.</t>

          <t>A TAM sends the following information in a
          InstallTARequest message to a target TEE:
            <list hangIndent="2" style="symbols">
              <t>The target SD information: SP ID and SD name</t>
              <t>Encrypted TA binary data. TA data is encrypted with the TEE
              SP AIK.</t>
              <t>TA metadata. It is optional to include the SP signer certificate
              for the SD to add if the SP has changed signer since the SD
              was created.</t>
            </list>
          </t>

          <t>The TEE processes the command given by the TAM to install a TA
            into an SP's SD. It does the following:
            <list hangIndent="2" style="symbols">
              <t>Validation
                <list hangIndent="2" style="symbols">
                  <t>The TEE validates the TAM message authenticity</t>
                  <t>Decrypt to get request content</t>
                  <t>Look up the SD with the SD name</t>
                  <t>Checks that the TAM owns the SD</t>
                  <t>Checks that the DSI hash matches which shows that the
                    device state hasn't changed</t>
                </list>
              </t>
              <t>If the request is valid, continue to do the TA validation
                <list hangIndent="2" style="symbols">
                  <t>Decrypt to get the TA binary data and any personalization
                  data with the "TEE SP AIK private key"</t>
                  <t>Check that SP ID is the one that is registered with
                  the SP SD</t>
                  <t>Check that the TA signer is either a newly given SP
                    certificate or the one that is already trusted by the
                    SD from the previous TA installation. The TA signing
                    method is specific to a TEE. This specification doesn't
                    define how a TA should be signed; a TAM should support
                    TEE specific TA signing when it supports that TEE.</t>
                  <t>If a TA signer is given in the request, add this
                  signer into the SD.</t>
                </list>
              </t>
              <t>If the above validation passed, continue to do TA installation
                <list hangIndent="2" style="symbols">
                  <t>The TEE re-encrypts the TA binary and its personalization
                  data with its own method.</t>
                  <t>The TEE enrolls and stores the TA in a secure
                  storage.</t>
                </list>
              </t>
              <t>Construct a response message. This involves signing
              encrypted status information for the requesting TAM.</t>
            </list>
          </t>

          <section anchor="installtareq" title="InstallTARequest Message">
            <figure>
              <preamble>The request message for InstallTA has the
              following JSON format.</preamble>
              <artwork><![CDATA[
{
  "InstallTATBSRequest": {
    "ver": "1.0",
    "rid": "<unique request ID>",
    "tid": "<transaction ID>",
    "tee": "<TEE routing name from the DSI for the SD's target>",
    "nextdsi": true | false,
    "dsihash": "<hash of DSI returned in the prior query>",
    "content": ENCRYPTED {
      "tamid": "<TAM ID previously assigned to the SD>",
      "spid": "<SPID value>",
      "sdname": "<SD name for the domain to install the TA>",
      "spcert": "<BASE64 encoded SP certificate >", // optional
      "taid": "<TA identifier>"
    },
    "encrypted_ta": {
      "key": "<JWE enveloped data of a 256-bit symmetric key by
               the recipient's TEEspaik public key>",
      "iv": "<hex of 16 random bytes>",
      "alg": "<encryption algoritm. AESCBC by default.",
      "ciphertadata": "<BASE64 encoded encrypted TA binary data>",
      "cipherpdata": "<BASE64 encoded encrypted TA personalization
                      data>"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the message, <list hangIndent="2" style="hanging">
              <t hangText="rid -"> A unique value to identify this
              request</t>
              <t hangText="tid -"> A unique value to identify this
              transaction. It can have the same value for the tid in the
              preceding GetDeviceStateRequest.</t>
              <t hangText="tee -"> TEE ID returned from the previous
              GetDeviceStateResponse </t>
              <t hangText="nextdsi -"> Indicates whether the up-to-date
              Device State Information (DSI) is to be returned in the
              response to this request.</t>
              <t hangText="dsihash -"> The BASE64-encoded SHA256 hash
              value of the DSI data returned in the prior TAM operation
              with this target TEE. This value is always included such
              that a receiving TEE can check whether the device state has
              changed since its last query. It helps enforce SD update
              order in the right sequence without accidentally overwriting an
              update that was done simultaneously.</t>
              <t hangText="content -"> The "content" is a JSON encrypted
              message that includes actual input for the SD update. The
              standard JSON content encryption key (CEK) is used, and the
              CEK is encrypted by the target TEE's public key.</t>
              <t hangText="tamid -"> SD owner claim by TAM - An SD owned
              by a TAM will be associated with a trusted identifier
              defined as an attribute in the signer TAM certificate.</t>
              <t hangText="spid -"> SP identifier of the TA owner SP</t>
              <t hangText="sdname -"> the name of the target SD where the
              TA is to be installed</t>
              <t hangText="spcert -"> an optional field to specify the SP
              certificate that signed the TA. This is sent if the SP has
              a new certificate that hasn't been previously registered
              with the target SD where the TA should be installed.</t>
              <t hangText="taid -"> the identifier of the TA application
              to be installed</t>
              <t hangText="encrypted_ta -"> the message portion contains
              encrypted TA binary data and personalization data. The TA
              data encryption key is placed in "key", which is encrypted
              by the recipient's public key, using JWE enveloped structure.
              The TA data encryption uses symmetric key based encryption
              such as AESCBC.</t>
            </list></t>

            <figure>
              <preamble>According to the OTrP message template, the full
              request InstallTARequest is a signed message over the
              InstallTATBSRequest as follows.
              </preamble>

              <artwork><![CDATA[
{
    "InstallTARequest": {
        "payload": "<InstallTATBSRequest JSON above>",
        "protected": "<integrity-protected header contents>",
        "header": "<non-integrity-protected header contents>",
        "signature": "<signature contents signed by TAM private key>"
    }
}
             ]]></artwork>
            </figure>
          </section>

          <section anchor="installtaresp" title="InstallTAResponse Message">
            <t>The response message for a InstallTARequest contains the
            following content.</t>

            <figure>
              <artwork><![CDATA[
{
  "InstallTATBSResponse": {
    "ver": "1.0",
    "status": "<operation result>",
    "rid": "<the request ID received>",
    "tid": "<the transaction ID received>",
    "content": ENCRYPTED {
      "reason":"<failure reason detail>", // optional
      "did": "<the device id hash>",
      "dsi": "<Updated TEE state, including all SD owned by
        this TAM>"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the response message, the following fields MUST be supplied.
             <list hangIndent="2" style="hanging">
              <t hangText="did - "> the SHA256 hash of the device TEE
              certificate. This shows the device ID explicitly to the
              receiving TAM.</t>
             </list>
            </t>

            <t>The final message InstallTAResponse looks like the
            following.</t>

            <figure>
              <artwork><![CDATA[
{
    "InstallTAResponse": {
        "payload":"<InstallTATBSResponse JSON above>",
        "protected": {
            "<BASE64URL of signing algorithm>"
        },
        "signature": "<signature contents signed by TEE device
          private key (BASE64URL)>"
    }
}

             ]]></artwork>
            </figure>

            <t>When the TEE fails to respond, the OTrP Broker will not provide
              a subsequent response to the TAM. The TAM should treat this as
              if the device has gone offline where a response is never
              delivered back.</t>
          </section>

          <section anchor="installtaerrors" title="Error Conditions">
            <t>An error may occur if a request isn't valid or the TEE
            runs into some error. The list of possible errors are as follows.
            Refer to the <xref target="errorcodelist">
            Error Code List</xref> for detailed causes and actions.

              <list hangIndent="2" style="hanging">
                <t hangText="ERR_REQUEST_INVALID"></t>
                <t hangText="ERR_UNSUPPORTED_MSG_VERSION"></t>
                <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG"></t>
                <t hangText="ERR_DEV_STATE_MISMATCH"></t>
                <t hangText="ERR_SD_NOT_FOUND"></t>
                <t hangText="ERR_TA_INVALID"></t>
                <t hangText="ERR_TA_ALREADY_INSTALLED"></t>
                <t hangText="ERR_TEE_FAIL"></t>
                <t hangText="ERR_TEE_RESOURCE_FULL"></t>
                <t hangText="ERR_TAM_NOT_AUTHORIZED"></t>
                <t hangText="ERR_TAM_NOT_TRUSTED"></t>
              </list>
            </t>
          </section>
        </section> <!-- install TA -->

        <section anchor="updateta" title="UpdateTA">
          <t>This TAM-initiated command can update a TA and its data in an
          SP's SD that it manages for the following purposes.
            <list hangIndent="2" style="numbers">
              <t>Update TA binary</t>
              <t>Update TA's personalization data</t>
            </list>
          </t>

          <t>The TAM presents the proof of the SD ownership to a TEE, and
          includes related information in its signed message. The entire
          request is also encrypted for end-to-end confidentiality.</t>

          <t>The TEE processes the command from the TAM to update the TA of
            an SP SD. It does the following:
            <list hangIndent="2" style="symbols">
              <t>Validation
                <list hangIndent="2" style="symbols">
                  <t>The TEE validates the TAM message authenticity</t>
                  <t>Decrypt to get request content</t>
                  <t>Look up the SD with the SD name</t>
                  <t>Checks that the TAM owns the SD</t>
                  <t>Checks DSI hash matches that the device state hasn't
                  changed</t>
                </list>
              </t>
              <t>TA validation
                <list hangIndent="2" style="symbols">
                  <t>Both TA binary and personalization data are
                  optional, but at least one of them shall be present in
                  the message</t>
                  <t>Decrypt to get the TA binary and any personalization
                  data with the "TEE SP AIK private key"</t>
                  <t>Check that SP ID is the one that is registered with
                  the SP SD</t>
                  <t>Check that the TA signer is either a newly given SP certificate
                  or the one in SD.</t>
                  <t>If a TA signer is given in the request, add this
                  signer into the SD.</t>
                </list>
              </t>
              <t>If the above validation passes, continue to do TA update
                <list hangIndent="2" style="symbols">
                  <t>The TEE re-encrypts the TA binary and its personalization
                  data with its own method</t>
                  <t>The TEE replaces the existing TA binary and its
                  personalization data with the new binary and data.</t>
                </list>
              </t>
              <t>Construct a response message. This involves signing a
              encrypted status information for the requesting TAM.</t>
            </list>
          </t>

          <section anchor="updatetareq" title="UpdateTARequest Message">
            <figure>
              <preamble>The request message for UpdateTA has the
              following JSON format.</preamble>
              <artwork><![CDATA[
{
  "UpdateTATBSRequest": {
    "ver": "1.0",
    "rid": "<unique request ID>",
    "tid": "<transaction ID>",
    "tee": "<TEE routing name from the DSI for the SD's target>",
    "nextdsi": true | false,
    "dsihash": "<hash of DSI returned in the prior query>",
    "content": ENCRYPTED {
      "tamid": "<TAM ID previously assigned to the SD>",
      "spid": "<SPID value>",
      "sdname": "<SD name for the domain to be created>",
      "spcert": "<BASE64 encoded SP certificate >", // optional
      "taid": "<TA identifier>"
    },
    "encrypted_ta": {
      "key": "<JWE enveloped data of a 256-bit symmetric key by
               the recipient's TEEspaik public key>",
      "iv": "<hex of 16 random bytes>",
      "alg": "<encryption algoritm. AESCBC by default.",
      "ciphernewtadata": "<Change existing TA binary to this new TA
          binary data(BASE64 encoded and encrypted)>",
      "ciphernewpdata": "<Change the existing data to this new TA
          personalization data(BASE64 encoded and encrypted)>"
          // optional
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the message, <list hangIndent="2" style="hanging">
              <t hangText="rid -"> A unique value to identify this
              request</t>
              <t hangText="tid -"> A unique value to identify this
              transaction. It can have the same value for the tid in the
              preceding GetDeviceStateRequest.</t>
              <t hangText="tee -"> TEE ID returned from the previous
              GetDeviceStateResponse </t>
              <t hangText="nextdsi -"> Indicates whether the up-to-date
              Device State Information (DSI) is to be returned in the
              response to this request.</t>
              <t hangText="dsihash -"> The BASE64-encoded SHA256 hash
              value of the DSI data returned in the prior TAM operation
              with this target TEE. This value is always included such
              that a receiving TEE can check whether the device state has
              changed since its last query. It helps enforce SD update
              order in the right sequence without accidentally overwriting an
              update that was done simultaneously.</t>
              <t hangText="content -"> The "content" is a JSON encrypted
              message that includes actual input for the SD update. The
              standard JSON content encryption key (CEK) is used, and the
              CEK is encrypted by the target TEE's public key.</t>
              <t hangText="tamid -"> SD owner claim by TAM - an SD owned
              by a TAM will be associated with a trusted identifier
              defined as an attribute in the signer TAM certificate.</t>
              <t hangText="spid -"> SP identifier of the TA owner SP</t>
              <t hangText="spcert -"> an optional field to specify the SP
              certificate that signed the TA. This is sent if the SP has
              a new certificate that hasn't been previously registered
              with the target SD where the TA is to be installed.</t>
              <t hangText="sdname -"> the name of the target SD where the
              TA should be updated</t>
              <t hangText="taid -"> an identifier for the TA application
              to be updated</t>
              <t hangText="encrypted_ta -"> the message portion contains
              newly encrypted TA binary data and personalization data.</t>
            </list></t>

            <figure>
              <preamble>According to the OTrP message template, the full
              request UpdateTARequest is a signed message over the
              UpdateTATBSRequest as follows.
              </preamble>

              <artwork><![CDATA[


{
    "UpdateTARequest": {
        "payload": "<UpdateTATBSRequest JSON above>",
        "protected": "<integrity-protected header contents>",
        "header": "<non-integrity-protected header contents>",
        "signature": "<signature contents signed by TAM private key>"
    }
}
             ]]></artwork>
            </figure>
          </section>

          <section anchor="updatetaresp" title="UpdateTAResponse Message">
            <t>The response message for a UpdateTARequest contains the
            following content.</t>

            <figure>
              <artwork><![CDATA[
{
  "UpdateTATBSResponse": {
    "ver": "1.0",
    "status": "<operation result>",
    "rid": "<the request ID received>",
    "tid": "<the transaction ID received>",
    "content": ENCRYPTED {
      "reason": "<failure reason detail>", // optional
      "did": "<the device id hash>",
      "dsi": "<Updated TEE state, including all SD owned by
        this TAM>"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the response message, the following fields MUST be supplied.
             <list hangIndent="2" style="hanging">
              <t hangText="did - "> the SHA256 hash of the device TEE
              certificate. This shows the device ID explicitly to the
              receiving TAM.</t>
             </list>
            </t>

            <t>The final message UpdateTAResponse looks like the
            following.</t>

            <figure>
              <artwork><![CDATA[
{
    "UpdateTAResponse": {
        "payload":"<UpdateTATBSResponse JSON above>",
        "protected": {
            "<BASE64URL of signing algorithm>"
        },
        "signature": "<signature contents signed by TEE device
          private key (BASE64URL)>"
    }
}

             ]]></artwork>
            </figure>

            <t>When the TEE fails to respond, the OTrP Broker will not provide
              a subsequent response to the TAM. The TAM should treat this as
              if the device has gone offline where a response is never
              delivered back.</t>
          </section>

          <section anchor="updatetaerrors" title="Error Conditions">
            <t>An error may occur if a request isn't valid or the TEE
            runs into some error. The list of possible errors are as follows.
            Refer to the <xref target="errorcodelist">
            Error Code List</xref> for detailed causes and actions.

              <list hangIndent="2" style="hanging">
                <t hangText="ERR_REQUEST_INVALID"></t>
                <t hangText="ERR_UNSUPPORTED_MSG_VERSION"></t>
                <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG"></t>
                <t hangText="ERR_DEV_STATE_MISMATCH"></t>
                <t hangText="ERR_SD_NOT_FOUND"></t>
                <t hangText="ERR_TA_INVALID"></t>
                <t hangText="ERR_TA_NOT_FOUND"></t>
                <t hangText="ERR_TEE_FAIL"></t>
                <t hangText="ERR_TAM_NOT_AUTHORIZED"></t>
                <t hangText="ERR_TAM_NOT_TRUSTED"></t>
              </list>
            </t>
          </section>
        </section> <!-- update TA -->

        <section anchor="deleteta" title="DeleteTA">
          <t>This operation defines OTrP messages that allow a TAM
          to instruct a TEE to delete a TA for an SP in a given SD. A TEE
          will delete a TA from an SD and also TA data in the TEE.
          A Client Application cannot directly access TEE or OTrP
          Broker to delete a TA.
          </t>

          <section anchor="deletetareq" title="DeleteTARequest Message">
            <figure>
              <preamble>The request message for DeleteTA has the
              following JSON format.</preamble>
              <artwork><![CDATA[
{
  "DeleteTATBSRequest": {
    "ver": "1.0",
    "rid": "<unique request ID>",
    "tid": "<transaction ID>",
    "tee": "<TEE routing name from the DSI for the SD's target>",
    "nextdsi": true | false,
    "dsihash": "<hash of DSI returned in the prior query>",
    "content": ENCRYPTED {
      "tamid": "<TAM ID previously assigned to the SD>",
      "sdname": "<SD name of the TA>",
      "taid": "<the identifier of the TA to be deleted from the
               specified SD>"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the message, <list hangIndent="2" style="hanging">
              <t hangText="rid -"> A unique value to identify this
              request</t>
              <t hangText="tid -"> A unique value to identify this
              transaction. It can have the same value for the tid in the
              preceding GetDeviceStateRequest.</t>
              <t hangText="tee -"> The TEE ID returned from the previous
              GetDeviceStateResponse </t>
              <t hangText="nextdsi -"> Indicates whether the up-to-date
              Device State Information (DSI) is to be returned in the
              response to this request.</t>
              <t hangText="dsihash -"> The BASE64-encoded SHA256 hash
              value of the DSI data returned in the prior TAM operation
              with this target TEE. This value is always included such
              that a receiving TEE can check whether the device state has
              changed since its last query. It helps enforce SD update
              order in the right sequence without accidentally overwriting an
              update that was done simultaneously.</t>
              <t hangText="content -"> The "content" is a JSON encrypted
              message that includes actual input for the SD update. The
              standard JSON content encryption key (CEK) is used, and the
              CEK is encrypted by the target TEE's public key.</t>
              <t hangText="tamid -"> SD owner claim by TAM - an SD owned
              by a TAM will be associated with a trusted identifier
              defined as an attribute in the signer TAM certificate.</t>
              <t hangText="sdname -"> the name of the target SD where the
              TA is installed</t>
              <t hangText="taid -"> an identifier for the TA application
              to be deleted</t>
            </list></t>

            <figure>
              <preamble>According to the OTrP message template, the full
              request DeleteTARequest is a signed message over the
              DeleteTATBSRequest as follows.
              </preamble>

              <artwork><![CDATA[


{
    "DeleteTARequest": {
        "payload": "<DeleteTATBSRequest JSON above>",
        "protected": "<integrity-protected header contents>",
        "header": "<non-integrity-protected header contents>",
        "signature": "<signature contents signed by TAM
            private key>"
    }
}
             ]]></artwork>
            </figure>
          </section>

          <section anchor="deletetareqproc"
            title="Request Processing Requirements at a TEE">

            <t>A TEE processes a command from a TAM to delete a TA of an SP
            SD. It does the following:
             <list hangIndent="2" style="numbers">
              <t>Validate the JSON request message
                <list hangIndent="2" style="symbols">
                  <t>The TEE validates TAM message authenticity</t>
                  <t>Decrypt to get request content</t>
                  <t>Look up the SD and the TA with the given SD name and
                  TA ID</t>
                  <t>Checks that the TAM owns the SD, and TA is installed
                  in the SD</t>
                  <t>Checks that the DSI hash matches and the the device state
                    hasn't changed</t>
                </list>
              </t>
              <t>Deletion action
                <list hangIndent="2" style="symbols">
                  <t>If all the above validation points pass, the TEE
                  deletes the TA from the SD</t>
                  <t>The TEE SHOULD also delete all personalization data for
                  the TA</t>
                </list>
              </t>
              <t>Construct DeleteTAResponse message.</t>
             </list>
            </t>

            <t>If a request is illegitimate or the signature doesn't pass, a
            "status" property in the response will indicate the error
            code and cause.
            </t>

          </section>

          <section anchor="deletetaresp" title="DeleteTAResponse Message">
            <t>The response message for a DeleteTARequest contains the
            following content.</t>

            <figure>
              <artwork><![CDATA[
{
  "DeleteTATBSResponse": {
    "ver": "1.0",
    "status": "<operation result>",
    "rid": "<the request ID received>",
    "tid": "<the transaction ID received>",
    "content": ENCRYPTED {
      "reason": "<failure reason detail>", // optional
      "did": "<the device id hash>",
      "dsi": "<Updated TEE state, including all SD owned by
        this TAM>"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the response message, the following fields MUST be supplied.
             <list hangIndent="2" style="hanging">
              <t hangText="did - "> the SHA256 hash of the device TEE
              certificate. This shows the device ID explicitly to the
              receiving TAM.</t>
             </list>
            </t>

            <t>The final message DeleteTAResponse looks like the
            following.</t>

            <figure>
              <artwork><![CDATA[
{
    "DeleteTAResponse": {
        "payload": "<DeleteTATBSResponse JSON above>",
        "protected": {
            "<BASE64URL of signing algorithm>"
        },
        "signature": "<signature contents signed by TEE device
            private key (BASE64URL)>"
    }
}

             ]]></artwork>
            </figure>

            <t>When the TEE fails to respond, the OTrP Broker will not provide
              a subsequent response to the TAM. The TAM should treat this as
              if the device has gone offline where a response is never
              delivered back.</t>
          </section>

          <section anchor="deletetaerrors" title="Error Conditions">
            <t>An error may occur if a request isn't valid or the TEE
            runs into some error. The list of possible errors are as follows.
            Refer to the <xref target="errorcodelist">
            Error Code List</xref> for detailed causes and actions.

              <list hangIndent="2" style="hanging">
                <t hangText="ERR_REQUEST_INVALID"></t>
                <t hangText="ERR_UNSUPPORTED_MSG_VERSION"></t>
                <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG"></t>
                <t hangText="ERR_DEV_STATE_MISMATCH"></t>
                <t hangText="ERR_SD_NOT_FOUND"></t>
                <t hangText="ERR_TA_NOT_FOUND"></t>
                <t hangText="ERR_TEE_FAIL"></t>
                <t hangText="ERR_TAM_NOT_AUTHORIZED"></t>
                <t hangText="ERR_TAM_NOT_TRUSTED"></t>
              </list>
            </t>
          </section>
        </section> <!-- delete TA -->

      </section>

    </section>

    <section anchor="TAMuse" title="Response Messages a TAM May Expect">
      <t>A TAM expects some feedback from a remote device when a request
        message is delivered to a device. The following three types of
        responses SHOULD be supplied.
      </t>

      <t><list hangIndent="4" style="hanging">
              <t hangText="Type 1: ">Expect a valid TEE-generated
              response message</t>
      <t>A valid TEE signed response may contain errors detected by a TEE, e.g.
        a TAM is trusted but some TAM-supplied data is missing, for example, SP ID
        doesn't exist. TEE MUST be able to sign and encrypt.
      </t>
      <t>If a TEE isn't able to sign a response, the TEE returns an error to
        the OTrP Broker without giving any other internal information. The OTrP
        Broker will be generating the response.
      </t>
      </list></t>

      <t><list hangIndent="4" style="hanging">
              <t hangText="Type 2: ">
              The OTrP Broker generated error message when TEE fails. OTrP
              Broker errors will be defined in this document.</t>
              <t>A Type 2 message has the following format.</t>
      </list></t>

      <figure>
        <artwork><![CDATA[
      {
        "OTrPBrokerError": {
            "ver": "1.0",
            "rid": "",
            "tid": "",
            "errcode": "ERR_AGENT_TEE_UNKNOWN | ERR_AGENT_TEE_BUSY"
        }
      }
           ]]></artwork>
      </figure>

      <t><list hangIndent="4" style="hanging">
              <t hangText="Type 3: ">
        OTrP Broker itself isn't reachable or fails. A Client Application is
        responsible to handle error and respond the TAM in its own way. This is
        out of scope for this specification.</t>
      </list></t>

    </section>

    <section anchor="basicprofile" title="Basic Protocol Profile">
      <t>This section describes a baseline for interoperability among
      the protocol entities, mainly, the TAM and TEE.</t>

      <t>A TEE MUST support RSA algorithms. It is optional to support
      ECC algorithms. A TAM SHOULD use a RSA certificate for TAM message
      signing. It may use an ECC certificate if it detects that the TEE
      supports ECC according to the field "supportedsigalgs" in a TEE
      response.</t>

      <t>A TAM MUST support both RSA 2048-bit algorithm and ECC P-256
      algorithms. With this, a TEE and TFW certificate can be either RSA
      or ECC type. </t>

      <t>JSON signing algorithms
        <list hangIndent="2" style="symbols">
          <t>RSA PKCS#1 with SHA256 signing : "RS256"</t>
          <t>ECDSA with SHA256 signing : "ES256"</t>
        </list>
      </t>

      <t>JSON asymmetric encryption algorithms (describes key-exchange
      or key-agreement algorithm for sharing symmetric key with TEE):
        <list hangIndent="2" style="symbols">
          <t>RSA PKCS#1  : "RSA1_5"</t>
          <t>ECDH using TEE ECC P-256 key and ephemeral ECC key
             generated by TAM : "ECDH-ES+A128W"</t>
        </list>
      </t>

      <t>JSON symmetric encryption algorithms (describes symmetric
      algorithm for encrypting body of data, using symmetric key
      transferred to TEE using asymmetric encryption):
        <list hangIndent="2" style="symbols">
          <t>Authenticated encryption AES 128 CBC with SHA256 :
             {"enc":"A128CBC-HS256"}</t>
        </list>
      </t>
    </section>

    <section anchor="impl" title="Attestation Implementation Consideration">
      <!-- NOTE: this section could be moved to Appendix in RFC -->
      <t>
        It is important to know that the state of a device is appropriate
        before trusting that a device is what it says it is. The attestation
        scheme for OTrP must also be able to cope with different TEEs,
        including those that are OTrP
        compliant and those that use another mechanism. In the initial
        version, only one active TEE is assumed.
      </t>
      <t>
        It is out of scope how the TAM and the device implement the trust
        hierarchy verification. However, it is helpful to understand what each
        system provider should do in order to properly implement an OTrP trust
        hierarchy.
      </t>
      <t>
        In this section, we provide some implementation reference
        consideration.
      </t>

      <section anchor="otrptfw" title="OTrP Trusted Firmware">
        <section anchor="attestsigner" title="Attestation signer">
          <t>
            It is proposed that attestation for OTrP is based on the TFW
            layer, and that further attestation is not
            performed within the TEE itself during Security Domain
            operations. The rationale is that the device boot process
            will be defined to start with a secure bootloader protected
            with a harden key in eFUSE. The process releases attestation
            signing capabilities into the TFW once a trust boot has been
            established. In this way the release of the attestation signer
            can be considered
            the first "platform configuration metric", using Trust Computing
            Group (TCG) terminology.
          </t>
        </section>

        <section anchor="tfwreq" title="TFW Initial Requirements">
          <t>
            <list counter="reqs" hangIndent="4" style="format R%d">
              <t>The TFW must be possible for verification during boot
              </t>
              <t>The TFW must allow a public / private key pair to be generated
                during device manufacture
              </t>
              <t>The public key and certificate must be possible to store
                securely
              </t>
              <t>The private key must be possible to store encrypted at rest
              </t>
              <t>The private key must only be visible to the TFW when it is
                decrypted
              </t>
              <t>The TFW must be able to read a list of root and
              intermediate certificates that it can use to check
              certificate chains with. The list must be stored such that
              it cannot be tampered with
              </t>
              <t>Need to allow a TEE to access its unique TEE
              specific private key
              </t>
            </list>
          </t>
        </section>
      </section>

      <section anchor="teeload" title="TEE Loading">
        <t>During boot, the TFW is required to start all of the root TEEs. Before
        loading them, the TFW must first determine whether the code sign
        signature of the TEE is valid. If TEE integrity is confirmed, the TEE
        may be started. The TFW must then be able to receive the identity certificate
        from the TEE (if that TEE is OTrP compliant). The identity certificate
        and keys will need to be baked into the TEE image, and therefore also
        covered by the code signer hash during the manufacturing process. The
        private key for the identity certificate must be securely protected.
        The private key for a TEE identity must never be released no matter how
        the public key and certificate are released to the TFW.
        </t>
        <t>Once the TFW has successfully booted a TEE and retrieved the
        identity certificate, the TFW will commit this to the platform configuration
        register (PCR) set, for later use during attestation. At minimum, the
        following data must be committed to the PCR for each TEE:
        </t>
        <t>
          <list style="numbers">
            <t>Public key and certificate for the TEE</t>
            <t>TEE identifier that can be used later by a TAM to identify this
              TEE
            </t>
          </list>
        </t>
      </section>

      <section anchor="attest" title="Attestation Hierarchy">
        <t>The attestation hierarchy and seed required for TAM protocol
        operation must be built into the device at manufacture. Additional TEEs
        can be added post-manufacture using the scheme proposed, but it is
        outside of the current scope of this document to detail that.
        </t>
        <t>It should be noted that the attestation scheme described is based on
        signatures. The only decryption that may take place is through the
        use of a bootloader key.
        </t>

        <section title="Attestation Hierarchy Establishment: Manufacture">
          <t>
            During manufacture the following steps are required:
          </t>
          <t>
            <list style="numbers">
              <t>A device-specific TFW key pair and certificate are burnt into
                the device. This key pair will be used for
                signing operations performed by the TFW.
              </t>
              <t>TEE images are loaded and include a TEE instance-specific
                key pair and certificate. The key pair and certificate are included
                in the image and covered by the code signing hash.
              </t>
              <t>The process for TEE images is repeated for any subordinate
                TEEs, which are additional TEEs after the root TEE that some
                devices have.
              </t>
            </list>
          </t>
        </section>

        <section title="Attestation Hierarchy Establishment: Device Boot">
          <t>During device boot the following steps are required:</t>
          <t>
            <list style="numbers">
              <t>The boot module releases the TFW private key by decrypting it with
                the bootloader key.
              </t>
              <t>The TFW verifies the code-signing signature of the active TEE
                 and places its TEE public key into a signing buffer, along with
                 its identifier for later access. For a non-OTrP TEE, the TFW
                 leaves the TEE public key field blank.
              </t>
              <t>The TFW signs the signing buffer with the TFW private key.</t>
              <t>Each active TEE performs the same operation as the TFW, building
                up their own signed buffer containing subordinate TEE
                information.
              </t>
            </list>
          </t>
        </section>

        <section title="Attestation Hierarchy Establishment: TAM">
          <t>Before a TAM can begin operation in the marketplace to support
            devices of a given TEE, it must obtain a TAM certificate from a
            CA that is registered in the trust store of devices with that TEE.
            In this way, the TEE can check the intermediate and root CA and
            verify that it trusts this TAM to perform operations on the TEE.
          </t>
        </section>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>There are two IANA requests: a media type and list of error codes.</t>

      <t>This section first requests that IANA assign a media type:
          application/otrp+json.</t>
        <t>
        <list hangIndent="2" style="hanging">
         <t hangText="Type name:"> application</t>
         <t hangText="Subtype name:"> otrp+json</t>
         <t hangText="Required parameters:"> none</t>
         <t hangText="Optional parameters:"> none</t>
         <t hangText="Encoding considerations:"> Same as encoding considerations of
         application/json as specified in Section 11 of <xref target="RFC7159"/></t>
         <t hangText="Security considerations:"> See Section 12 of <xref target="RFC7159"/>
         and Section 14 of this document</t>
         <t hangText="Interoperability considerations:"> Same as interoperability
         considerations of application/json as specified in
         <xref target="RFC7159"/></t>
         <t hangText="Published specification:"> <xref target="I-D.ietf-teep-architecture"/></t>
         <t hangText="Applications that use this media type:"> OTrP implementations</t>
         <t hangText="Fragment identifier considerations:"> N/A</t>
         <t hangText="Additional information:">
           <list hangIndent="2" style="hanging">
             <t hangText="Deprecated alias names for this type:"> N/A</t>
             <t hangText="Magic number(s):"> N/A</t>
             <t hangText="File extension(s):"> N/A</t>
             <t hangText="Macintosh file type code(s):"> N/A</t>
           </list>
         </t>
         <t hangText="Person to contact for further information:">
            teep@ietf.org</t>
         <t hangText="Intended usage:"> COMMON</t>
         <t hangText="Restrictions on usage:"> none</t>
         <t hangText="Author:"> See the "Authors' Addresses" section of this document</t>
         <t hangText="Change controller:"> IETF</t>
        </list>
        </t>

      <t>The error code listed in the next section will be registered.</t>

      <section anchor="errorcodelist" title="Error Code List">
        <t>This section lists error codes that could be reported by
        a TA or TEE in a device in responding to a TAM request, and a
        separate list that OTrP Broker may return when the TEE fails to
        respond.</t>

        <section anchor="teeerrorcodelist" title="TEE Signed Error Code List">
        <t>
          <list hangIndent="2" style="hanging">
            <t hangText="ERR_DEV_STATE_MISMATCH -"> A TEE will return
            this error code if the DSI hash value from TAM doesn't match
            the has value of the device's current DSI.</t>

            <t hangText="ERR_SD_ALREADY_EXISTS -">  This error will
            occur if an SD to be created already exists in the TEE.</t>

            <t hangText="ERR_SD_NOT_EMPTY -"> This is reported if a
            target SD isn't empty.</t>

            <t hangText="ERR_SDNAME_ALREADY_USED">A TEE will return this
            error code if the new SD name already exists in the TEE.</t>

            <t hangText="ERR_REQUEST_INVALID -"> This error will
            occur if the TEE meets any of the following conditions with a
            request message: (1) The request from a TAM has an
            invalid message structure; mandatory information is
            absent in the message. undefined member or structure is
            included.  (2) TEE fails to verify signature of the
            message or fails to decrypt its contents.</t>

            <t hangText="ERR_SPCERT_INVALID -">  If a new SP
            certificate for the SD to be updated is not valid, then
            the TEE will return this error code.</t>

            <t hangText="ERR_TA_ALREADY_INSTALLED -"> While installing a TA,
            a TEE will return this error if the TA has already been installed
            in the SD.</t>

            <t hangText="ERR_TA_INVALID -"> This error will occur when a TEE
            meets any of following conditions while checking validity of
            TA: (1) The TA binary has a format that the TEE can't recognize. (2)
            The TEE fails to decrypt the encoding of the TA binary and
            personalization data. (3) If an SP isn't registered with the SP SD
            where the TA will be installed.</t>

            <t hangText="ERR_TA_NOT_FOUND -"> This error will occur when
            the target TA doesn't exist in the SD.</t>

            <t hangText="ERR_TEE_FAIL -"> If the TEE fails to process a
              request because of an internal error, it will return this
              error code.</t>

            <t hangText="ERR_TEE_RESOURCE_FULL -"> This error is reported
            when a device resource isn't available anymore such as
            storage space is full.</t>

            <t hangText="ERR_TFW_NOT_TRUSTED -"> A TEE is responsible for
              determining that the underlying device firmware is trustworthy.
              If the TEE determines the TFW is not trustworthy, then
              this error will occur.</t>

            <t hangText="ERR_TAM_NOT_TRUSTED -">  Before processing a
            request, a TEE needs to make sure whether the sender TAM is
            trustworthy by checking the validity of the TAM certificate,
            etc. If the TEE finds that the TAM is not trustworthy, then
            it will return this error code.</t>

            <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG -">  This error
            will occur if a TEE receives a request message encoded with
            cryptographic algorithms that the TEE doesn't support.</t>

            <t hangText="ERR_UNSUPPORTED_MSG_VERSION -">  This error
            will occur if a TEE receives a message version that
            the TEE can't deal with.</t>
          </list>
        </t>
        </section>
      </section>
    </section>

    <section anchor="security" title="Security Consideration">
      <section title="Cryptographic Strength">
        <t>The strength of the cryptographic algorithms, using the measure of
           'bits of security' defined in NIST SP800-57 allowed for OTrP
            is:</t>
        <t><list style="symbols">
         <t>At a minimum, 112 bits of security. The limiting factor for this is
            the RSA-2048 algorithm, which is indicated as providing 112 bits
            of symmetric key strength in
            SP800-57. It is important that RSA is supported in order to enhance
            the interoperability of the protocol.</t>
        <t>The option exists to choose algorithms providing 128 bits of
           security. This requires using TEE devices that support ECC P256.
        </t>
        </list>The available algorithms and key sizes specified in this document
          are based on industry standards.
          Over time the recommended or allowed cryptographic algorithms may
          change. It is important that the OTrP allows for crypto-agility.
          In this specification, TAM and TEE can negotiate an agreed upon
          algorithm where both include their supported algorithm in OTrP
          message.
        </t>
      </section>

      <section title="Message Security">
        <t>OTrP messages between the TAM and TEE are protected by message
        security using JWS and JWE. The 'Basic protocol profile' section of
        this document describes the algorithms used for this. All OTrP TEE
        devices and OTrP TAMs must meet the requirements of the basic profile.
        In the future additional 'profiles' can be added.</t>

        <t>PKI is used to ensure that the TEE will only communicate with a
        trusted TAM, and to ensure that the TAM will only communicate with a
        trusted TEE.</t>
      </section>

      <section title="TEE Attestation">
        <t>It is important that the TAM can trust that it is talking to a
        trusted TEE. This is achieved through attestation. The TEE has a private
        key and certificate built into it at manufacture, which is used to sign
        data supplied by the TAM. This allows the TAM to verify that the TEE is
        trusted. </t>

        <t>It is also important that the TFW (trusted firmware) can be checked.
        The TFW has a private key and certificate built into it at manufacture,
        which allows the TEE to check that that the TFW is trusted. </t>

        <t>The GetDeviceState message therefore allows the TAM to check that it
        trusts the TEE, and the TEE at this point will check whether it trusts
        the TFW. </t>
      </section>

      <section title="TA Protection">
        <t>
          A TA will be delivered in an encrypted form. This encryption is an
          additional layer within the message encryption described in the
          <xref target="basicprofile"/> of this document. The TA binary
          is encrypted for each target device with the device's TEE SP AIK
          public key. A TAM can either do this encryption itself or
          provide the TEE SP AIK public key to an SP such that the SP
          encrypts the encrypted TA for distribution to the TEE.
        </t>

        <figure>
          <preamble>The encryption algorithm can use a random AES 256 key
          "taek" with a 16 byte random IV, and the "taek" is encrypted by the
          "TEE SP AIK public key". The following encrypted TA data structure
          is expected by a TEE: </preamble>

          <artwork><![CDATA[
"encrypted_ta_bin": {
  "key": "<JWE enveloped data of a 256-bit symmetric key by
         the recipient's TEEspaik public key>",
  "iv": <hex of 16 random bytes>",
  "alg": "AESCBC",
  "cipherdata": "<BASE64 encoded encrypted TA binary data>"
}
         ]]></artwork>
        </figure>

      </section>

      <section title="TA Personalization Data">
      <t>
        An SP or TAM can supply personalization data for a TA to initialize for
        a device. Such data is passed through an InstallTA command from a TAM.
        The personalization data itself is (or can be) opaque to the TAM.
        The data can be from the SP without being revealed to the TAM.
        The data is sent in an encrypted manner in a
        request to a device such that only the device can decrypt. A device's
        TEE SP AIK public key for an SP is used to encrypt the data. Here JWE
        enveloping is used to carry all encryption key parameters along with
        encrypted data.
      </t>

        <figure>
          <artwork><![CDATA[
"encrypted_ta_data": { // "TA personalization data"
    "key": "<JWE enveloped data of a 256-bit symmetric key by
             the recipient's TEEspaik public key>",
    "iv": "<hex of 16 random bytes>",
    "alg": "AESCBC",
    "cipherdata": "<BASE64 encoded encrypted TA personalization
                   data>"
  }
         ]]></artwork>
        </figure>

      </section>

      <section title="TA Trust Check at TEE">
        <t>
        A TA binary is signed by a TA signer certificate. This TA signing
        certificate/private key belongs to the SP, and may be self-signed (i.e.,
        it need not participate in a trust hierarchy). It is the responsibility
        of the TAM to only allow verified TAs from trusted SPs into the system.
        Delivery of that TA to the TEE is then the responsibility of the TEE,
        using the security mechanisms provided by the OTrP.
        </t>

        <t>
        We allow a way for an (untrusted) application to check the
        trustworthiness of a TA. OTrP Broker has a function to allow
        a Client Application to query the information about a TA.
        </t>

        <t>
          An application in the Rich O/S may perform verification of the TA by
          verifying the signature of the TA. The GetTAInformation
          function is available to return the TEE supplied TA signer and TAM signer
          information to the application. An application can do additional
          trust checks on the certificate returned for this TA. It might trust
          the TAM, or require additional SP signer trust chaining.
        </t>
      </section>

      <section title="One TA Multiple SP Case">
        <t> A TA for multiple SPs must have a different identifier per SP.
          A TA will be installed in a different SD for each respective SP. </t>
      </section>

      <section title="OTrP Broker Trust Model">
        <t> An OTrP Broker could be malware in the vulnerable REE. A
        Client Application will connect its TAM provider for required TA
        installation. It gets command messages from the TAM, and passes
        the message to the OTrP Broker. </t>

        <t> The OTrP is a conduit for enabling the TAM to communicate
        with the device's TEE to manage SDs and TAs. All TAM messages are
        signed and sensitive data is encrypted such that the OTrP Broker cannot
        modify or capture sensitive data. </t>
      </section>

      <section title="OCSP Stapling Data for TAM Signed Messages">
        <t> The GetDeviceStateRequest message from a TAM to a TEE shall include
        OCSP stapling data for the TAM's signer certificate and for
        intermediate CA certificates up to the root certificate so that the TEE
        can verify the signer certificate's revocation status. </t>

        <t> A certificate revocation status check on a TA signer certificate is
        OPTIONAL by a TEE. A TAM is responsible for vetting a TA and the SP
        before it distributes them to devices. A TEE will
        trust a TA signer certificate's validation status done by a TAM when it
        trusts the TAM. </t>
      </section>

      <section title="Data Protection at TAM and TEE">
        <t> The TEE implementation provides protection of data on the device.
        It is the responsibility of the TAM to protect data on its servers. </t>
      </section>

      <section title="Privacy Consideration">
        <t> Devices are issued with a unique TEE certificate to attest the
          device's validity. This uniqueness also creates a privacy and
          tracking risk that must be mitigated. </t>

        <t> The TEE will only release the TEE certificate to a trusted TAM (it
        must verify the TAM certificate before proceeding). OTrP
        is designed such that only a TAM can obtain the TEE device
        certificate and firmware certificate - the GetDeviceState message
        requires signature checks to validate the TAM is trusted, and OTrP
        delivers the device's certificate(s) encrypted such that only that TAM
        can decrypt the response. A Client Application will never see the
        device certificate. </t>

        <t> An SP-specific TEE SP AIK  (TEE SP Anonymous Key) is generated by
        the protocol for Client Applications. This provides a way for the
        Client Application to validate some data that the TEE may send
        without requiring
        the TEE device certificate to be released to the client device rich O/S
        , and to optionally allow an SP to encrypt a TA for a target device
        without the SP needing to be supplied with the TEE device certificate. </t>
      </section>

      <section title="Threat Mitigation">
        <t> A rogue application may perform excessive TA loading. An OTrP Broker
        implementation should protect against excessive calls. </t>

        <t> Rogue applications might request excessive SD creation. The
        TAM is responsible to ensure this is properly guarded against. </t>

        <t> Rogue OTrP Broker could replay or send TAM messages out of
        sequence: e.g., a TAM sends update1 and update2. The OTrP Broker
        replays update2 and update1 again, creating an unexpected result that
        a client wants. "dsihash" is used to mitigate this. The TEE MUST
        store DSI state and check that the DSI state matches before it
        does another update.
        </t>

        <t> Concurrent calls from a TAM to a TEE MUST be handled properly by a
        TEE. If multiple concurrent TAM operations take place, these could
        fail due to the "dsihash" being modified by another concurrent operation.
        The TEE is responsible for resolve any locking such that one
        application cannot lock other applications from using the TEE, except
        for a short term duration of the TAM operation taking place. For
        example, an OTrP operation that starts but never completes (e.g. loss
        of connectivity) must not prevent subsequent OTrP messages from being
        executed. </t>
      </section>

      <section title="Compromised CA">
        <t> A root CA for TAM certificates might get compromised. Some TEE
        trust anchor update mechanism is expected from device OEMs. A compromised
        intermediate CA is covered by OCSP stapling and OCSP validation check
        in the protocol. A TEE should validate certificate revocation about a
        TAM certificate chain. </t>

        <t> If the root CA of some TEE device certificates is compromised,
        these devices might be rejected by a TAM, which is a decision of the
        TAM implementation and policy choice. Any intermediate CA for TEE device
        certificates SHOULD be validated by TAM with a Certificate
        Revocation List (CRL) or Online Certificate Status Protocol (OCSP)
        method.
        </t>
      </section>

      <section title="Compromised TAM">
        <t> The TEE SHOULD use validation of the supplied TAM certificates and
        OCSP stapled data to validate that the TAM is trustworthy. </t>

        <t> Since PKI is used, the integrity of the clock within the TEE
        determines the ability of the TEE to reject an expired TAM certificate,
        or revoked TAM certificate. Since OCSP stapling includes signature
        generation time, certificate validity dates are compared to the current
        time.</t>
      </section>

      <section title="Certificate Renewal">
        <t> TFW and TEE device certificates are expected to be long lived,
          longer than the
        lifetime of a device. A TAM certificate usually has a moderate
        lifetime of 2 to 5 years. A TAM should get renewed or rekeyed
        certificates. The root CA certificates for a TAM, which are embedded
        into the trust anchor store in
        a device, should have long lifetimes that don't require device trust
        anchor update. On the other hand, it is imperative that OEMs or device
        providers plan for support of trust anchor update in their shipped
        devices. </t>
      </section>

    </section> <!-- Security Consideration -->

  

  </middle>

  <back>
    <references title="Normative References">
     &RFC2119;
     &RFC4648;
     &RFC7159;
     &RFC7515;
     &RFC7516;
     &RFC7517;
     &RFC7518;
    </references> <!-- Normative References --> 

    <references title="Informative References">

      &I-D.ietf-teep-architecture;      
  
      <reference anchor="GPTEE">
        <front>
          <title>Global Platform, GlobalPlatform Device Technology:
            TEE System Architecture, v1.0</title>
          <author>
            <organization>Global Platform</organization>
          </author>
          <date year="2013" />
        </front>
      </reference>
      <reference anchor="GPTEECLAPI">
        <front>
          <title>Global Platform, GlobalPlatform Device Technology:
            TEE Client API Specification, v1.0</title>
          <author>
            <organization>Global Platform</organization>
          </author>
          <date year="2013" />
        </front>
      </reference>
    </references> <!-- Informative References --> 

  <section anchor="Acknowledgements" title="Acknowledgements">
      <t>We thank Alin Mutu for his contribution to many discussion that helped
      to design the trust flow mechanisms, and the creation of the flow diagrams.
      We also thank the following people (in alphabetical order) for their input
      and review: Sangsu Baek, Rob Coombs, Dapeng Liu, and
      Pengfei Zhao.
      </t>
    </section> <!-- Acknowledgements --> 

   <section anchor="Contributors" title="Contributors">
    
    <t>We would like to thank the following individuals for their contributions to an earlier version
    of this specification.</t> 
    
        <figure>
          <artwork><![CDATA[
- Brian Witten
  Symantec
  brian_witten@symantec.com

- Tyler Kim
  Solacia
  tylerkim@iotrust.kr

- Nick Cook
  Arm Ltd.
  nicholas.cook@arm.com
  
- Minho Yoo  
  IoTrust
  minho.yoo@iotrust.kr
         ]]></artwork>
        </figure>
    </section> <!-- Contributors --> 
    
  </back>
</rfc>
